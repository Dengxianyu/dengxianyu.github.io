<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="邓先雨的三味书屋"><meta name="keywords" content="博客, 前端, 生活"><title>ES6学习笔记 | 零落之角</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6学习笔记</h1><a id="logo" href="/.">零落之角</a><p class="description">人生虽不快乐，而仍能乐观</p></div><div id="nav-menu"><a href="/./"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="关键字"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ES6学习笔记</h1><div class="post-meta"><a href="/2018/07/19/ES6学习笔记/#comments" class="comment-count"></a><p><span class="date">2018-07-19</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="0-前言"><a class="markdownIt-Anchor" href="#0-前言"></a> 0. 前言</h2>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，本文是我再读阮一峰老师的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a>的读书笔记，中间有很多自己的总结和代码案例。</p>
<h2 id="1-变量的声明和作用域"><a class="markdownIt-Anchor" href="#1-变量的声明和作用域"></a> 1. 变量的声明和作用域</h2>
<ul>
<li>ES6 新增 let 命令、const 命令和{}代码块内为块级作用域的概念。</li>
<li>const 与 let 的区别：定义的变量，如果是基本类型则不可以再被赋值，如果是引用类型是可以增删属性方法的，但是重新赋值。const 命令是不允许声明时不赋值的。</li>
<li>let 命令、const 命令与 var 命令定义变量的区别
<ol>
<li>定义的变量是块级作用域，var 定义的变量是函数作用域；</li>
<li>定义的变量不可重复定义；</li>
<li>定义的变量没有变量提升；</li>
<li>定义的全局变量不再是顶层对象的属性。</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义的变量是块级作用域，var定义的变量是函数作用域</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a; <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义的变量不可重复定义</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>; <span class="comment">// b现在是1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义的变量没有变量提升</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">12</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 定义的全局变量不再是顶层对象的属性</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. let、const在for循环中的应用</span></span><br><span class="line"><span class="comment">// for循环设置循环变量的那部分(即括号内)是一个父作用域，而循环体内部是</span></span><br><span class="line"><span class="comment">//一个单独的子作用域，怎么理解呢？就是（）内和for循环的外界是相当于&#123;&#125;分</span></span><br><span class="line"><span class="comment">//开的，而循环体内部是在外部的&#123;&#125;代码块中的&#123;&#125;代码块，如下goto模拟</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    repeat: <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i++;</span><br><span class="line">        goto repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以如下，若在for循环中用let，则外界就获取不到outer，</span></span><br><span class="line"><span class="comment">// 而for循环内部可以获取到outer但是也可以重新定义该变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> outer = <span class="number">0</span>; outer &lt; <span class="number">1</span>; outer++) &#123;</span><br><span class="line">    <span class="keyword">const</span> outer = <span class="string">'inner outer'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(outer);  <span class="comment">// inner outer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(outer); <span class="comment">// ReferenceError: outer is not defined</span></span><br><span class="line"><span class="comment">// var定义的i在外界可以获取到，所以函数执行时是10</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// let定义的i在外界可以获取到，所以函数执行时是取函数定义时</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h2 id="2-解构赋值与扩展运算符"><a class="markdownIt-Anchor" href="#2-解构赋值与扩展运算符"></a> 2. 解构赋值与扩展运算符</h2>
<ul>
<li>解构赋值：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构，而解构可以极大的简化多个变量的赋值操作。解构赋值允许指定默认值，只有当解构的成员严格等于（===）undefined，默认值才会生效。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的解构赋值严格按照次序</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">const</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">const</span> [y = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">y; <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 对象的解构赋值和次数无关</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz; <span class="comment">// "aaa"</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">first</span>: <span class="string">"hello"</span>, <span class="attr">last</span>: <span class="string">"world"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f; <span class="comment">// 'hello'</span></span><br><span class="line">l; <span class="comment">// 'world'</span></span><br><span class="line"><span class="comment">// 注意对象的简写</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo; <span class="comment">// "aaa"</span></span><br><span class="line">bar; <span class="comment">// "bbb"</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">5</span> &#125;;</span><br><span class="line">y; <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 对已经声明的变量用于对象解构赋值，需要加括号，不然或被解析前面的&#123;&#125;会被解析成代码块而报语法错误</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123; x &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>扩展运算符：是三个点（…）表示，将一个任何带有 Iterator 接口的数据转为用逗号分隔的参数序列。它可以结合函数的参数和解构赋值可以很方便实现一些功能。如 ES5 中，一些函数支持传多个参数，但是若我们想传数组进入怎么办呢？通常是拿 function.apply(null, args)，现在可以直接用 function(…args)了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独在console使用其实是会报错的，因为它返回的是几个逗号的连接值</span></span><br><span class="line">...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// Unexpected number</span></span><br><span class="line"><span class="comment">// 最常用的作为函数的参数使用</span></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 可以把[]也看做一个运算符，里面即为其参数</span></span><br><span class="line">[...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// ES5中apply用扩展运算符来实现</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]) === <span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"><span class="comment">// 解构赋值时，会自动将变量赋值为数组，但是只能放在参数的最后一位，否则会报错</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">rest; <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 把实现了Iterator接口的数据转换成真正的数组，所以也可以转换</span></span><br><span class="line">[...<span class="string">'hello'</span>]; <span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)];</span><br></pre></td></tr></table></figure>
<h2 id="3-symbol新的数据类型"><a class="markdownIt-Anchor" href="#3-symbol新的数据类型"></a> 3. Symbol：新的数据类型</h2>
<p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型。</p>
<ol>
<li>是一种原始数据类型，所以 typeof 调用实例返回&quot;symbol&quot;，且是一种类似于字符串的非引用类型而非对象这种引用类型数据。</li>
<li>生成一个 Symbol 实例有两种方法，一种直接是 Symbol()，一种是 Symbol.for()，后者生成的会被登记在全局环境（可以在不同的 iframe 或 service worker 中取到同一个值）中供搜索，前者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。一般的接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。Symbol.keyFor()方法只会返回 Symbol.for()产生的 Symbol 实例的 key。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">"foo"</span>); <span class="comment">// Symbol(foo)</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>); <span class="comment">// Symbol(bar)</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"foo"</span>) === <span class="built_in">Symbol</span>(<span class="string">"foo"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"test"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"test"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(<span class="built_in">Symbol</span>(<span class="string">"foo"</span>)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(<span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>)); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。这一点上和 String 和 Number 是有区别的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"test"</span>); <span class="comment">// String &#123;"sss"&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">"test"</span>); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法，目的就是将语言更加规范化，如 instanceof 操作符会调用函数的[Symbol.hasInstance]方法、string 中 match、search、replace、split 这几个用到正则的都定义到了正则对象相应的方法。对象的 Symbol.iterator 属性，指向该对象的默认遍历器方法。</li>
</ol>
<h2 id="4-set-与-map-类"><a class="markdownIt-Anchor" href="#4-set-与-map-类"></a> 4. Set 与 Map 类</h2>
<ul>
<li>set 类用于生成一个可以遍历的但是其值都不重复(与===的唯一区别是 NaN 的判断)的数据结构的对象，如果把它和普通对象相比，其 key 值和 value 值是一样的，同时是可遍历的。如果和数组相比，添加相同的值会被忽略。</li>
<li>Set 实例的生成方法只能通过 new Set，所以 Set 是一个标准的构造函数且不可作为普通函数使用。它可以传任何具有 iterable 接口的其他数据结构，用来初始化。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>); <span class="comment">// [empty]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>); <span class="comment">// [empty]</span></span><br><span class="line"><span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// TypeError: Constructor Set requires 'new'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// Set(2) &#123;1, 2&#125;</span></span><br><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])]; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Set 类的实例有 size 属性，返回成员的个数，add、delete、has、clear 方法。同时有四个遍历方法，可以用于遍历成员：keys()、values()、entries()返回的都是遍历器对象，forEach()使用回调函数遍历每个成员。Set 类由于键名和键值是同一个值，所以 keys()、values()返回时相同的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size; <span class="comment">// 1</span></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size; <span class="comment">// 2</span></span><br><span class="line">s.add(<span class="number">1</span>)</span><br><span class="line">    .add(<span class="number">2</span>)</span><br><span class="line">    .add(<span class="number">2</span>);</span><br><span class="line">s.size; <span class="comment">// 4</span></span><br><span class="line">s.has(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.keys === <span class="built_in">Set</span>.prototype.values; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]).forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key + <span class="string">" : "</span> + value));</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Map 类型和普通对象的区别在于，但是“键”（key）的范围不限于字符串，各种类型的值（包括对象）都可以当作键，其也有 size 属性 has、clear 方法以及 keys()、values()、entries()遍历器生成函数和 forEach()遍历方法，和 Set 不同的是对键值的读写是通过 get、set 方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> objKey = &#123; <span class="attr">key</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> objVal = &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">m.set(<span class="string">"edition"</span>, <span class="number">6</span>); <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">"standard"</span>); <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">"nah"</span>); <span class="comment">// 键是 undefined</span></span><br><span class="line">m.set(objKey, objVal); <span class="comment">// 键是 对象</span></span><br><span class="line">m.size; <span class="comment">// 4</span></span><br><span class="line">m.get(objKey) === objVal; <span class="comment">// true</span></span><br><span class="line">m.delete(); <span class="comment">// true, 默认无参数就相当于传入undefined</span></span><br><span class="line">m.has(<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line">m.delete(<span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line">m.clear(), m.size; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"F"</span>, <span class="string">"no"</span>], [<span class="string">"T"</span>, <span class="string">"yes"</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F"</span></span><br><span class="line"><span class="comment">// "T"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "no"</span></span><br><span class="line"><span class="comment">// "yes"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"><span class="built_in">Map</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Map</span>.prototype.entries; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Map</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Map</span>.prototype.values; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>WeakSet 和 WeakMap 类都是不具备 iterator 接口的类，且和 Set 和 Map 的区别在于创建的实例都是弱引用，随时可能消失。这种弱引用的应用之处就是用于一些是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</li>
</ul>
<h2 id="5-iterator-和-forof-循环"><a class="markdownIt-Anchor" href="#5-iterator-和-forof-循环"></a> 5. Iterator 和 for…of 循环</h2>
<ul>
<li>遍历器接口：为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成 for…of 循环遍历操作。Iterator 的遍历过程是这样的：<br>
（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。<br>
（2）第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。<br>
（3）第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。<br>
（4）不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。<br>
所以一个对象如果要具备可被 for…of 循环调用的 Iterator 接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法（即后续讲到的 Generate 函数）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = start;</span><br><span class="line">        <span class="keyword">this</span>.stop = stop;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value++;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原生就具备 Iterator 接口的数据结构有：Array、String、Map、Set、函数的 arguments 对象、NodeList 对象、TypedArray。</li>
<li>调用 Iterator 接口的场合除了前面已经说过的解构赋值、扩展运算符还有一些构造函数（如 Array.from()、Map(), Set()）的传参以外，还有 yield*，它后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>for…of 循环相比于 forEach 方法，它可以与 break 和 continue 配合使用，且比纯粹的 for 循环简单。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">8</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 1 2 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟for循环需要循环次数的问题</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">console</span>.log(value * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-promise-对象"><a class="markdownIt-Anchor" href="#6-promise-对象"></a> 6. Promise 对象</h2>
<ul>
<li>js 回调地狱：由于一些不合理的写法，在回调函数中嵌套回调函数，所以函数体写的十分臃肿，大括号层层塌陷进去被戏称为回调地狱。而解决回调地狱的一种方式是将回调函数定义写在外层，直接把函数名传到回调的地方。现在 ES6 提供了 Promise 也是一种解决异步回调地狱的方式。</li>
<li>Promise 是异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise 对象有以下两个特点：
<ol>
<li>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这和事件的异步完全不同，Promise的状态可以在凝固后仍拿得到！</span></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">"data"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise对象已经改变为fulfilled"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    test.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="keyword">void</span> <span class="built_in">console</span>.log(<span class="string">"test"</span>));</span><br><span class="line">&#125;, <span class="number">1500</span>);</span><br><span class="line"><span class="comment">// Promise对象已经改变为fulfilled</span></span><br><span class="line"><span class="comment">// test</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Promise 是一个构造函数，用来生成 Promise 实例。构造函数接受一个<strong>函数</strong>作为参数，该函数的两个参数分别是由 JavaScript 引擎提供的 resolve 和 reject，resolve 和 reject 分别用于改变 promise 实例的状态，且仅能在这个函数中调用 resolve 或者 reject 修改，且一旦改变了就不会再变（如上所述）。生成的 promise 实例可以调用 then 方法和 catch 方法分别监听 promise 实例的状态改变后的回调函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生Ajax用promise封装</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(<span class="string">"post"</span>, <span class="string">"url"</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    xhr.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">test</span>: <span class="string">"test"</span> &#125;));</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>).textContent = result;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        errorTip &amp;&amp; errorTip(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  new Promise()参数中的函数体会立即执行，异步执行的是外部的then/catch回调，</span><br><span class="line"> *  且Promise实例的then/catch回调是在本轮“事件循环”结束时执行，</span><br><span class="line"> *  setTimeout(fn, 0)在下一轮“事件循环”开始时执行 </span><br><span class="line">*/</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"four"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"three"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"two"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Promise实例的状态一旦改变就不会再次被修改，</span><br><span class="line"> *  且一般改变状态后不应该再写语句。但是实际上写也会执行</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"shouldn't have"</span>);</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>));</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// shouldn't have</span></span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span><br><span class="line"> *  throw new Error("error")等价于reject(new Error("error"))</span><br><span class="line"> *  会被catch或者then的第二个函数捕获到</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>));</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: error</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</span><br><span class="line">&#125;).then(<span class="literal">null</span>, error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: error</span></span><br></pre></td></tr></table></figure>
<ul>
<li>resolve 或者 reject 的参数可以是一个 Promise 对象，这个时候只有当作参数的这个 Promise 对象状态变成 fulfilled 或者 rejected 时才会改变当前的 Promise 对象的状态。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const start = +new Date();</span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error("fail")), 3000);</span><br><span class="line">&#125;);</span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(p1), 1000);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(result =&gt; void console.log(result)).catch(error =&gt; &#123;</span><br><span class="line">    const end = +new Date();</span><br><span class="line">    console.log(`过了$&#123;(end - start) / 1000&#125;s`);</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line">// 过了3.001s</span><br><span class="line">// Error: fail</span><br></pre></td></tr></table></figure>
<ul>
<li>Promise.prototype.then：then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例），这个新的 Promise 的状态和 then 方法的返回值有关。可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then函数返回普通字符串，则会把结果当下一个then的参数，没有return就相当于undefined传入</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"first"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res); <span class="comment">// first</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// then函数返回Promise对象，则等该promise转换状态之后再执行后面的then，相当于该promise对象的then、catch</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"first"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">"second"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res); <span class="comment">// second</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"first"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="string">"error"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error); <span class="comment">// error</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结实现多个异步操作 顺序 执行的</span></span><br><span class="line"><span class="keyword">const</span> test1 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"test1 run"</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">const</span> test2 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"test2 run"</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">const</span> test3 = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"test3 run"</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">test1()</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> test2();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> test3();</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runByOrder</span>(<span class="params">promises = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!promises.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="keyword">typeof</span> p === <span class="string">"function"</span>)) <span class="keyword">return</span>;</span><br><span class="line">    promises.reduce(<span class="function">(<span class="params">pre, cur, curenetIndex</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> promise = curenetIndex === <span class="number">1</span> ? pre() : pre;</span><br><span class="line">        <span class="keyword">return</span> promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Promise.prototype.catch：catch 方法或捕获 promise 的 reject 或者运行中抛出的错误（throw Error）。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，错误也只会被处理一次。catch 方法和 then 一样返回的是一个新的 promise 对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">"error"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error); <span class="comment">// error</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 和上面的等价</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">"error"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error); <span class="comment">// error</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">"error"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error); <span class="comment">// error</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error); <span class="comment">// 不会打印，因为只会捕获一次</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>then 和 catch 返回的新的 promise 的状态是什么由什么决定呢？因为 then 和 reject 的参数是一个函数，其参数是上层 promise 的状态值，then 监听上一个的 return 值，catch 监听能够传播（Promise 对象的错误具有“冒泡”性质）到它这的 throw new Error(error)或者 reject(error)的 error。所以无论 then 或者 catch 函数中只要不 throw error 出来，则返回了一个新的 promise 对象状态为 fulfilled，否则状态为 rejected！</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">"data"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个then什么操作都不做，生成新的promise状态为fulfilled，传递数据为undefined</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data); <span class="comment">// undefined</span></span><br><span class="line">            <span class="comment">// 第二个then里throw error，生成新的promise状态为rejected，传递数据为"error"</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">            <span class="comment">// 不会走到这里</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 不会走到这里</span></span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error); <span class="comment">// error</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 不会走到这里，因为上一个then没有throw Error出来</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Promise.all()：接受一个数组作为参数，数组里预期每一个都是 Promise 实例，若不是会用 Promise.resolve 方法转化一下。这多个 Promise 实例（例如 p1、p2、p3），包装成一个新的 Promise 实例（例如 p），p 的状态由 p1、p2、p3 决定，分成两种情况：
<ol>
<li>只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</li>
<li>只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</li>
</ol>
</li>
<li>Promise.race()：同 Promise.all 的参数处理一样，不同的是竞速模式，会返回最快状态凝固的那个产生的新的 promise。</li>
<li>Promise.resolve()、Promise.reject()方法分别用于直接生成一个新的 Promise 状态已经改变的实例。</li>
</ul>
<h2 id="7-generator-函数"><a class="markdownIt-Anchor" href="#7-generator-函数"></a> 7. Generator 函数</h2>
<ul>
<li>前面已经讲到了 Generator 函数是产生遍历器对象的函数，为一些对象提供遍历器接口的。如下展示了原生的 String 部署了变量对象，其 String.prototype[Symbol.iterator]就是一个 Generator 函数。Generator 函数和普通函数的区别就是产生的结果是一个 iterator 对象，其 next 方法会每次返回一个{value:xxx, done: true/false}的对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype[<span class="built_in">Symbol</span>.iterator] <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> i = str[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">i.next(); <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">i.next(); <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">i.next(); <span class="comment">// &#123;value: 'c', done: false&#125;</span></span><br><span class="line">i.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line">i.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。它有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）。返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 表达式就是暂停标志。遍历器对象的 next 方法的运行逻辑如下：
<ol>
<li>遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</li>
<li>下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。</li>
<li>如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</li>
<li>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为普通对象设置其遍历器接口</span></span><br><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable]; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// next()方法支持传参作为“上次”yield的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dataConsumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Started"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> genObj = dataConsumer();</span><br><span class="line">genObj.next(); <span class="comment">// 返回值为&#123;value: undefined, done: false&#125;</span></span><br><span class="line"><span class="comment">// Started</span></span><br><span class="line">genObj.next(<span class="string">"a"</span>); <span class="comment">// 返回值为&#123;value: undefined, done: false&#125;</span></span><br><span class="line"><span class="comment">// 1. a</span></span><br><span class="line">genObj.next(<span class="string">"b"</span>); <span class="comment">// 返回值为&#123;value: 'result', done: false&#125;</span></span><br><span class="line"><span class="comment">// 2. b</span></span><br></pre></td></tr></table></figure>
<ul>
<li>yield* 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"x"</span>;</span><br><span class="line">    <span class="keyword">yield</span>* foo();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"y"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"x"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">        <span class="keyword">yield</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"y"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组的展平输出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">flat</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(v)) &#123;</span><br><span class="line">            <span class="keyword">yield</span>* flat(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f); <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-async-函数"><a class="markdownIt-Anchor" href="#8-async-函数"></a> 8. async 函数</h2>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便，但其实它只是 Generator 函数的语法糖。</p>
<ul>
<li>Generator 函数其实本身也是异步操作的思想，因为 generator 函数里面每次只是完成一个 yield 及之前的代码，但是 generator 的异步实现比较麻烦在于其必须执行生成一个对象且执行其 next 方法才真的执行，语义上并不好理解，所以有了 async 函数。</li>
<li>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">asyncPrint(<span class="string">"hello world"</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>async 函数由于返回的是一个 promise 对象，所以 promise 对象的状态时 resolved 还是 rejected 取决于函数体内部的一些执行，很有意思的是，async 函数里只要有没有处理的错误（没有 catch）就会终止里面的运行转到外部的 catch 或者直接终止。所以如果希望 async 函数不会被中断，必须要传一个已经做过 catch 错误处理的 promise 函数，那样返回的就又是新的 resolved 的 promise 而不会中断后面的操作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">"throw error!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"done!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = asyncFun(); <span class="comment">// 此时不会执行到打印done这个语句</span></span><br><span class="line">test.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// throw error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="9-es6-的类class"><a class="markdownIt-Anchor" href="#9-es6-的类class"></a> 9. ES6 的类—Class</h2>
<p>ES6 之前其实没有类的概念的，有的只是构造函数，我们有的时候趋向于把构造函数当作一个类，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<ul>
<li>constructor 方法就是构造方法，而 this 关键字则代表实例对象，可以省略 constructor 方法。class 中的其他方法均是类的内部方法，是不可枚举的，这与常规的 ES5 通过在构造函数的 prototype 上新增类的方法其实是可枚举的是不同的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Point1; <span class="comment">// "function"</span></span><br><span class="line">Point1 === Point1.prototype.constructor; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.keys(Point1.prototype); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point1.prototype); <span class="comment">// ["constructor","toString"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Point2 = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Point2.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Point2.prototype, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">Object</span>.keys(Point2.prototype); <span class="comment">// ["toString"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point2.prototype); <span class="comment">// ["constructor","toString"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数是怎么调用的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Rectangle(); <span class="comment">// Class constructor Rectangle cannot be invoked without 'new'</span></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>与函数一样，类也可以使用表达式的形式定义，其中类的名字只在 Class 的内部代码可用，指代当前类。且 class 和 function 不同的是，它定义的变量不存在变量提升，且和 let 或 const 一样不可重复定义。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在变量提升</span></span><br><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Me只能在class内部获取，且类的名字是MyClass而非Me</span></span><br><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    getClassName() &#123;</span><br><span class="line">        <span class="keyword">return</span> Me.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Me(); <span class="comment">// ReferenceError: Me is not defined</span></span><br><span class="line">MyClass.name; <span class="comment">// "Me"</span></span><br><span class="line"><span class="keyword">new</span> MyClass().getClassName(); <span class="comment">// "Me"</span></span><br><span class="line"><span class="comment">// 和 function 不同不可重复定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;&#125; <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span> </span>&#123;&#125; <span class="comment">// SyntaxError: Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>
<ul>
<li>class 的私有方法：ES6 暂时没有私有方法和私有属性，只能通过变通方法模拟实现。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一种做法是在命名上加以区别</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公有方法</span></span><br><span class="line">    foo(baz) &#123;</span><br><span class="line">        <span class="keyword">this</span>._bar(baz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    _bar(baz) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.snaf = baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有方法移出模块，因为模块内部的所有方法都是对外可见的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.snaf = baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    foo(...args) &#123;</span><br><span class="line">        bar.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">"bar"</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">"snaf"</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公有方法</span></span><br><span class="line">    foo(baz) &#123;</span><br><span class="line">        <span class="keyword">this</span>[bar](baz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    [bar](baz) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>[snaf] = baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>class 的静态方法：静态方法是指不会被实例继承，而是直接通过类来调用的。ES5 的构造函数静态方法就是在构造函数自身挂载方法就可以了，而 class 的静态方法仍写在类里面，只不过用 static 关键字前面说明。目前 class 只有静态方法，没有静态属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于静态方法是挂载在类本身上的，所以其函数内this指向的也是类本身而非类的prototype</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> bar() &#123;</span><br><span class="line">        <span class="keyword">this</span>.baz();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> baz() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    baz() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.bar(); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>ES6 之前的类的继承是通过原型链来实现的，基本思想是：把父类生成的实例加到子类的 prototype 属性上，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: Person,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">"human"</span></span><br><span class="line">&#125;;</span><br><span class="line">Teacher.prototype = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Person(), &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: Teacher,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Teacher();</span><br></pre></td></tr></table></figure>
<p>而 class 的继承是定义子类通过 extends 关键字，和其内部利用 super 对象获取父类的一些东西。</p>
<ul>
<li>子类的 constructor 可以省略，但是一旦不省略则必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。因为在子类的 constructor 方法中调用 super 方法后，相当于调用了父类的 constructor 方法生成了子类的实例，所以也只有在调用 super 方法之后也得不到 this。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> hello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 忽略子类的constructor函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint1</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    getColorType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"point"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和上面等价</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint2</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    getColorType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"point"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this必须要在super方法调用后才有</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类的静态方法，也会被子类继承。</span></span><br><span class="line">ColorPoint.hello(); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
<ul>
<li>super 既可作为函数调用（仅可以在 constructor 中），也可作为对象读取属性和方法，那它分别指代的是什么呢，而运行时的 this 指代什么呢？</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// super作为方法调用的是父类本身的构造函数，作为非方法在子类的非静态方法中相当于时父类.prototype，静态方法相当于父类本身</span></span><br><span class="line"><span class="comment">// 子类调用父类的静态方法的this就是子类本身，而非静态方法是实例本身</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.q = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="string">"super X"</span>;</span><br><span class="line">        <span class="keyword">this</span>.y = <span class="string">"super Y"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.z = <span class="string">"A: zzz"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 相当于A.prototype.constructor()</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 相当于时A.prototype，故返回2</span></span><br><span class="line">        <span class="keyword">this</span>.x = <span class="string">"sub X"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    get m() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.q; <span class="comment">// 相当于时A.prototype.q</span></span><br><span class="line">    &#125;</span><br><span class="line">    print1() &#123;</span><br><span class="line">        <span class="keyword">super</span>.print(); <span class="comment">// 相当于A.prototype.print().call(this)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> print2() &#123;</span><br><span class="line">        <span class="keyword">super</span>.print(); <span class="comment">// 相当于A.print().call(this)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m; <span class="comment">// undefined</span></span><br><span class="line">A.prototype.q = <span class="string">"qq"</span>;</span><br><span class="line">b.m; <span class="comment">// qq</span></span><br><span class="line">b.print1(); <span class="comment">// sub X super Y || this指向实例本身，它有自有属性x和继承属性y</span></span><br><span class="line">B.print(); <span class="comment">// A: zzz || B本身没有print方法，但是B的原型链上一层是A，它有print方法，这时候this其实是A还是B？B，B没有自有属性z，但是有继承属性z</span></span><br><span class="line">B.print2(); <span class="comment">// A: zzz || B通过super调用了A的print方法，这时候this其实是A还是B？B，B没有自有属性z，但是有继承属性z</span></span><br><span class="line">B.z = <span class="string">"B: zzz"</span>;</span><br><span class="line">B.print(); <span class="comment">// B: zzz || 这里就证明了this指代的确实是B而非A</span></span><br><span class="line">B.print2(); <span class="comment">// B: zzz || 这里就证明了this指代的确实是B而非A</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ES5 是先新建子类的实例对象 this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: MyArray,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</span><br><span class="line">colors.length; <span class="comment">// 0</span></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]; <span class="comment">// "red"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length; <span class="comment">// 1</span></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="10-module-的语法"><a class="markdownIt-Anchor" href="#10-module-的语法"></a> 10. Module 的语法</h2>
<p>ES6 的模块是引入 import 和 export 两个命令来实现模块的引入和对外接口，比较需要主要的是接口语法和 import 的静态导入</p>
<ul>
<li>import 和 export 命令可以出现在模块的任何位置（但是规范上当然出现在首尾），但是必须处于模块顶层，如果出现在块级作用域内就会报错。</li>
<li>import 和 export 的语法：export 只允许提供对外的接口。export default 可以允许直接输出一个常量出去，对应的 import 时直接可以以任何变量来引入。注意，和函数参数的解构不同，import 时是没有解构的，虽然看起来像解构，但是看 export default 的一个例子就知道。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 和上面等价</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    firstName,</span><br><span class="line">    multiply <span class="keyword">as</span> changedFoo</span><br><span class="line">    MyClass <span class="keyword">as</span> changedClass</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下都是错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> m = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"><span class="comment">// 对应上面的import</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;firstName, changedFoo, changedClass&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName <span class="keyword">as</span> new_name, year <span class="keyword">as</span> new_year&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">'Michael'</span></span><br><span class="line">    lastName: <span class="string">'Jackson'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是正确的import</span></span><br><span class="line"><span class="keyword">import</span> anyName <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"><span class="comment">// 以下是错误的import，因为import遇到大括号就会从export的接口去找对应的变量，而不是从export default的值去解构！！！</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"><span class="comment">// 模块的整体加载，如下circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>ES6 模块与 CommonJS 模块的差异:
<ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用;</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">counter</span>: counter,</span><br><span class="line">    <span class="attr">incCounter</span>: incCounter</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">"./lib"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="11-字符串的扩展"><a class="markdownIt-Anchor" href="#11-字符串的扩展"></a> 11. 字符串的扩展</h2>
<ul>
<li>字符串基础知识：JS 的编码方式是基于 UTF-16 编码的，即把每一个字符用 16 进制的 Unicode 码点表示，如<code>&quot;\u0061&quot; === &quot;a&quot;</code>，因为 a 在 ASCII 码表的序号是 97，换算成 16 进制即为 0x0061。所以这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。具体如何分解的参考<a href="https://segmentfault.com/q/1010000010112070" target="_blank" rel="external">js Unicode 码点问题</a>;</li>
<li>ES6 允许讲码点放进大括号，支持大于\uFFFF 的字符。<code>&quot;\u{1F680}&quot; === &quot;\uD83D\uDE80&quot;</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span>; <span class="comment">// "𠮷"</span></span><br><span class="line"><span class="comment">// 如果直接在\u后面跟上超过0xFFFF的数值（比如\u00617），只会解析前4位</span></span><br><span class="line"><span class="string">"\u00617"</span>; <span class="comment">// "a7"</span></span><br><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span>; <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>之前那些超过\uFFFF 的码点，用字符串的 length 判断它会占用 2 个，但其实它应该只是一个。而且 ES6 之前的字符串方法 charAt()或者像类数组取[x]无法读取真正的字符，只会返回前两个字节和后两个字节的值。同样的还有 String.fromCharCode 方法不能识别 32 位的 UTF-16 字符。ES6 提供了<strong>codePointAt</strong>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点，但是它仍是将其当做 2 个字符去处理，第一个返回整体的码点，第二个返回第二个字符的码点。还有<strong>String.fromCodePoint</strong>方法替代 String.fromCharCode 方法来处理 32 位的字符。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6之前的length和charAt方法处理不了4字节（2个16进制的Unicode码点）表示的字符</span></span><br><span class="line"><span class="string">"𠮷"</span>.length; <span class="comment">// 2</span></span><br><span class="line"><span class="string">"𠮷"</span>[<span class="number">0</span>]; <span class="comment">// "�"</span></span><br><span class="line"><span class="string">"𠮷"</span>.charAt(<span class="number">1</span>); <span class="comment">// "�"</span></span><br><span class="line"><span class="string">"𠮷"</span>.charCodeAt(<span class="number">0</span>); <span class="comment">// 55362，因为从上可以看出其前一个表示是\uD842，2+16*4+8*256+13*4096 = 55362</span></span><br><span class="line"><span class="string">"𠮷a"</span>.codePointAt(<span class="number">0</span>); <span class="comment">// 134071</span></span><br><span class="line"><span class="string">"𠮷a"</span>.codePointAt(<span class="number">1</span>); <span class="comment">// 57271 === 0xDFB7</span></span><br><span class="line"><span class="string">"𠮷a"</span>.codePointAt(<span class="number">2</span>); <span class="comment">// 97</span></span><br><span class="line"><span class="comment">// 判断字符是否是4字节字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20bb7</span>); <span class="comment">// "ஷ"</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20bb7</span>); <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 for…of 循环遍历。for…of 遍历字符串最大的优点就是可以识别大于 0xFFFF 的码点</li>
<li>ES6 为字符串提供的新方法有 includes()、startWith()、endWith()、repeat()、padStart()、padEnd()方法，非常实用，例子如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// includes、startWith、endWith三个方法都支持第二个参数，表示开始搜索的位置。</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">"Hello world!"</span>;</span><br><span class="line">s.startsWith(<span class="string">"Hello"</span>); <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">"d!"</span>); <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">"o"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// includes和startWith第二个参数是指从第n个位置直到字符串结束</span></span><br><span class="line">s.includes(<span class="string">"Hello"</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br><span class="line">s.startsWith(<span class="string">"world"</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// endWith第二个参数是指针对前n个字符</span></span><br><span class="line">s.endsWith(<span class="string">"Hello"</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// repeat方法返回一个新字符串，表示将原字符串重复n次</span></span><br><span class="line"><span class="string">"x"</span>.repeat(<span class="number">3</span>); <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">"hello"</span>.repeat(<span class="number">2</span>); <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">"na"</span>.repeat(<span class="number">0</span>); <span class="comment">// ""</span></span><br><span class="line"><span class="comment">// padStart()用于头部补全，padEnd()用于尾部补全</span></span><br><span class="line"><span class="string">"x"</span>.padStart(<span class="number">5</span>, <span class="string">"ab"</span>); <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">"x"</span>.padStart(<span class="number">4</span>, <span class="string">"abcdef"</span>); <span class="comment">// 'abcx'</span></span><br><span class="line"><span class="string">"x"</span>.padEnd(<span class="number">5</span>, <span class="string">"ab"</span>); <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">"x"</span>.padEnd(<span class="number">4</span>, <span class="string">"abcdef"</span>); <span class="comment">// 'xabc'</span></span><br><span class="line"><span class="string">"xxx"</span>.padStart(<span class="number">2</span>, <span class="string">"ab"</span>); <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">"xxx"</span>.padEnd(<span class="number">2</span>, <span class="string">"ab"</span>); <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="comment">// padStart和padEnd省略第二个参数，默认使用空格补全长度</span></span><br><span class="line"><span class="string">"x"</span>.padStart(<span class="number">4</span>); <span class="comment">// '   x'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ES6 提供的模板字符串（``标识）可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量，只需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性，甚至还能调用函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>; <span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"><span class="comment">// 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</span></span><br><span class="line">$(<span class="string">"#list"</span>).html(<span class="string">`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`</span>);</span><br></pre></td></tr></table></figure>
<h2 id="12-对象和数组的扩展"><a class="markdownIt-Anchor" href="#12-对象和数组的扩展"></a> 12. 对象和数组的扩展</h2>
<ul>
<li>属性（包括方法）的简洁表示法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">"bar"</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; foo &#125;;</span><br><span class="line">baz; <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    method() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://Object.is" target="_blank" rel="external">Object.is</a> 方法也是用于比较两个值是否相等，和===的唯一区别是 NaN 和+0 与-0</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Object.getOwnPropertyDescriptor 方法可以获取对象某个自有属性的描述对象，Object.getOwnPropertyDescriptors 方法可以获取对象全部自有属性的描述对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">    get bar() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  foo:&#123;</span></span><br><span class="line"><span class="comment">//      value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;,</span></span><br><span class="line"><span class="comment">//  bar:&#123;</span></span><br><span class="line"><span class="comment">//      get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对象实例的<code>__proto__</code>虽然在各个浏览器都有部署，但是其他运行环境不一定部署，所以 ES6 提供了新的 API 函数，Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作，ES5 已经有了）代替。</li>
<li>super 关键字：在对象的方法函数里，this 指代的是对象本身，ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。但是在写法上，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">"hello"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">"world"</span>,</span><br><span class="line">    find() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find(); <span class="comment">// "hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">super</span>.foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">super</span>.foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Object.assign(target, source1, source2, …)方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<ol>
<li>
<p>Object.assign 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123; <span class="attr">b</span>: <span class="string">"c"</span> &#125;,</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">"invisible"</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">"hello"</span></span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// &#123; b: 'c' &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Object.assign 可以用来处理数组，但是会把数组视为对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Object.assign 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source1 = &#123;</span><br><span class="line">    get foo1() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123;</span><br><span class="line">    get foo2() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line"><span class="comment">// &#123;foo1: 1, foo2: undefined&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>Object.keys()，Object.values()，Object.entries()分别返回对象可遍历的自有可枚举属性（即不含继承的且不含 Symbol 属性且 enumerable: true 的属性）的[key1, key2, …]、[value1, value2, …]、[[key1, value1], [key2, value2], …]</p>
</li>
<li>
<p>总结对于对象的遍历：</p>
<ol>
<li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li>
<li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</li>
<li>Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</li>
<li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li>
<li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(<span class="built_in">Object</span>);</span><br><span class="line"><span class="comment">// ["length", "name", "prototype", "assign", "getOwnPropertyDescriptor",</span></span><br><span class="line"><span class="comment">//"getOwnPropertyDescriptors", "getOwnPropertyNames", "getOwnPropertySymbols",</span></span><br><span class="line"><span class="comment">// "is", "preventExtensions", "seal", "create", "defineProperties",</span></span><br><span class="line"><span class="comment">//"defineProperty", "freeze", "getPrototypeOf", "setPrototypeOf",</span></span><br><span class="line"><span class="comment">//"isExtensible", "isFrozen", "isSealed", "keys", "entries", "values"]</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(<span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="comment">// ["constructor", "__defineGetter__", "__defineSetter__", "hasOwnProperty",</span></span><br><span class="line"><span class="comment">//"__lookupGetter__", "__lookupSetter__", "isPrototypeOf",</span></span><br><span class="line"><span class="comment">//"propertyIsEnumerable", "toString", "valueOf", "__proto__",</span></span><br><span class="line"><span class="comment">//"toLocaleString"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</li>
<li>Array.of 方法用于将一组值，转换为数组。主要用来弥补数组构造函数 Array()的不足（因为参数个数的不同，会导致 Array()的行为有差异）。</li>
<li>数组实例的 find() 和 findIndex() ：find 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员，如果没有符合条件的成员，则返回 undefined。findIndex 和其一样只是返回下标或者-1。</li>
<li>数组实例的 includes()：基本用来取代 indexOf，因为其采用===，所以不能查找 NaN。对于+0 与-0 仍保持和===一致。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></span><br><span class="line">[+<span class="number">0</span>].includes(<span class="number">-0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="13-函数的扩展"><a class="markdownIt-Anchor" href="#13-函数的扩展"></a> 13. 函数的扩展</h2>
<ul>
<li>函数参数支持传入默认值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">"World"</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">"Hello"</span>); <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">"Hello"</span>, <span class="string">"China"</span>); <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">"Hello"</span>, <span class="string">""</span>); <span class="comment">// Hello</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x, y = <span class="number">5</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数默认值可以与解构赋值的默认值，结合起来使用</span></span><br><span class="line">foo(&#123;&#125;); <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;); <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;); <span class="comment">// 1 2</span></span><br><span class="line">foo(); <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当传入默认值时，相当于在函数初始化参数解析时，参数会形成一个单独的作用域（context），是函数作用域的父作用域，是函数外层作用域的子作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有默认值时，x和函数作用域里面的处于相同作用域下，所以再次定义会报错</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">f(x); <span class="comment">// SyntaxError: Identifier 'y' has already been declared</span></span><br><span class="line"><span class="comment">// 含有默认值时，参数形成单独作用域，x引用的是外层作用域的1</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ES6 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ES6 引入了 rest 参数用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个<strong>数组</strong>，该变量将多余的参数放入数组中。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">        sum += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>箭头函数（=&gt;）至于省略 return 时返回对象时必须加大括号都是注意事项，最主要的箭头函数和普通函数的区别有：
<ol>
<li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象；</li>
<li>不可以当作构造函数 和 Generator 函数，也就是说，不可以使用 new 命令，否则会抛出一个错误；</li>
<li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替</li>
</ol>
</li>
</ul>
</div><div class="post-categories"><span><a href="/categories/JavaScript/" class="category">JavaScript</a></span></div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/进阶知识/">进阶知识</a></div><div class="post-nav"><a href="/2018/08/23/css基础知识/" class="pre">css基础知识</a><a href="/2018/06/14/再读犀牛书：JavaScript的基础知识集锦/" class="next">再读犀牛书：JavaScript的基础知识集锦</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODA2MS8xNDU5MQ=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-前言"><span class="toc-text"> 0. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-变量的声明和作用域"><span class="toc-text"> 1. 变量的声明和作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-解构赋值与扩展运算符"><span class="toc-text"> 2. 解构赋值与扩展运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-symbol新的数据类型"><span class="toc-text"> 3. Symbol：新的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-set-与-map-类"><span class="toc-text"> 4. Set 与 Map 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-iterator-和-forof-循环"><span class="toc-text"> 5. Iterator 和 for…of 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-promise-对象"><span class="toc-text"> 6. Promise 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-generator-函数"><span class="toc-text"> 7. Generator 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-async-函数"><span class="toc-text"> 8. async 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-es6-的类class"><span class="toc-text"> 9. ES6 的类—Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-module-的语法"><span class="toc-text"> 10. Module 的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-字符串的扩展"><span class="toc-text"> 11. 字符串的扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-对象和数组的扩展"><span class="toc-text"> 12. 对象和数组的扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-函数的扩展"><span class="toc-text"> 13. 函数的扩展</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/css基础知识/">css基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/ES6学习笔记/">ES6学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/再读犀牛书：JavaScript的基础知识集锦/">再读犀牛书：JavaScript的基础知识集锦</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/基础知识/" style="font-size: 15px;">基础知识</a> <a href="/tags/进阶知识/" style="font-size: 15px;">进阶知识</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">邓先雨(Dengxy).</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>