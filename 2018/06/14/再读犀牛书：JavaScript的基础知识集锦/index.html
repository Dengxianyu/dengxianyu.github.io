<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="邓先雨的三味书屋"><meta name="keywords" content="博客, 前端, 生活"><title>再读犀牛书：JavaScript的基础知识集锦 | 零落之角</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">再读犀牛书：JavaScript的基础知识集锦</h1><a id="logo" href="/.">零落之角</a><p class="description">人生虽不快乐，而仍能乐观</p></div><div id="nav-menu"><a href="/./"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="关键字"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">再读犀牛书：JavaScript的基础知识集锦</h1><div class="post-meta"><a href="/2018/06/14/再读犀牛书：JavaScript的基础知识集锦/#comments" class="comment-count"></a><p><span class="date">2018-06-14</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="1-new-一个构造函数实际做了什么"><a class="markdownIt-Anchor" href="#1-new-一个构造函数实际做了什么"></a> 1. new 一个构造函数，实际做了什么？</h2>
<ul>
<li>创建一个新的空对象{}；</li>
<li>传入指定的参数，并且以这个新的空对象当做 this 来调用构造函数，以此来初始化新创建对象的属性；</li>
<li>一般的，构造函数不会返回一个值，而新创建的且被初始化后的对象就是整个表达式的值；</li>
<li>如果构造函数确实返回了一个对象值，那么这个对象值则是整个表达式的值，而新创建的对象则废弃了，如果是非对象值则一律返回新创建的且被初始化后的对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="string">"b"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Foo2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="string">"b"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Foo3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="string">"b"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Foo1(); <span class="comment">// =&gt; &#123; a: "a", b: "b" &#125;</span></span><br><span class="line"><span class="keyword">new</span> Foo2(); <span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> Foo3(); <span class="comment">// =&gt; &#123; a: "a", b: "b" &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-那些奇奇怪怪的运算符"><a class="markdownIt-Anchor" href="#2-那些奇奇怪怪的运算符"></a> 2. 那些奇奇怪怪的运算符</h2>
<h3 id="21-typeof返回什么"><a class="markdownIt-Anchor" href="#21-typeof返回什么"></a> 2.1 typeof()返回什么？</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof(null)记住返回obeject</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// =&gt; "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// =&gt; "obeject"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// =&gt; "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span>; <span class="comment">// =&gt; "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1000</span>; <span class="comment">// =&gt; "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// =&gt; "number"</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// =&gt; "obeject"</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// =&gt; "function"</span></span><br></pre></td></tr></table></figure>
<h3 id="22-tostring-valueof返回什么"><a class="markdownIt-Anchor" href="#22-tostring-valueof返回什么"></a> 2.2 toString()、valueOf()返回什么？</h3>
<ol>
<li>普通的对象:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Obeject本身的toString、valueOf方法</span></span><br><span class="line">(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;).valueOf(); <span class="comment">// =&gt; &#123;a:1&#125;</span></span><br><span class="line">(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;).toString(); <span class="comment">// =&gt; "[object Object]"</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>原生类：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的toString返回每一个子项的toString并用逗号连接</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">true</span>, &#123;&#125;].toString(); <span class="comment">// =&gt; "1,true,[object Object]"</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().toString(); <span class="comment">// =&gt; "Wed Nov 22 2017 09:32:55 GMT+0800 (中国标准时间)"</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'abc'</span>&#125;).toString(); <span class="comment">// "function () &#123;return 'abc'&#125;"</span></span><br><span class="line">(<span class="regexp">/[a-z]/i</span>).toString(); <span class="comment">// "/[a-z]/i"</span></span><br><span class="line"><span class="comment">// Object.prototype.toString是常用的判断原生哪种类型的好方法</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/a/</span>); <span class="comment">// "[object RegExp]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call((<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="comment">// 用户自定义的类该方法无法识别</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(a); <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="comment">// 除了Date类返回时间戳，其余全部返回对象自身</span></span><br><span class="line">(&#123;&#125;).valueOf(); <span class="comment">// &#123;&#125;</span></span><br><span class="line">(fnction()&#123;&#125;).valueOf(); <span class="comment">// ƒ ()&#123;&#125;</span></span><br><span class="line">[<span class="number">11</span>].valueOf(); <span class="comment">// [11]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().valueOf(); <span class="comment">// =&gt; 1511314312177</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>一些特殊值：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined、null、普通数字是没有toString()方法的</span></span><br><span class="line"><span class="number">99.</span>toString(); <span class="comment">// 报错=&gt; SyntaxError</span></span><br><span class="line">(<span class="number">99</span>).toString(); <span class="comment">// "99"</span></span><br><span class="line">(<span class="number">99</span>).toString(<span class="number">16</span>); <span class="comment">// "63"</span></span><br><span class="line">(<span class="number">99</span>).toString(<span class="number">8</span>); <span class="comment">// "143"</span></span><br><span class="line"><span class="literal">true</span>.toString(); <span class="comment">// =&gt; "true"</span></span><br><span class="line"><span class="literal">NaN</span>.toString(); <span class="comment">// =&gt; "NaN"</span></span><br><span class="line"><span class="literal">Infinity</span>.toString(); <span class="comment">// =&gt; "Infinity"</span></span><br></pre></td></tr></table></figure>
<h3 id="23-boolean中哪些返回了-false"><a class="markdownIt-Anchor" href="#23-boolean中哪些返回了-false"></a> 2.3 Boolean()中哪些返回了 false？</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if()语句、！操作符，都会调用Boolean()方法</span></span><br><span class="line"><span class="comment">// 以下全是false，其余全是true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span> || <span class="literal">null</span> || <span class="literal">false</span> || <span class="string">""</span> || <span class="number">0</span> || <span class="literal">NaN</span>);</span><br></pre></td></tr></table></figure>
<h3 id="24-string中哪些特殊注意的"><a class="markdownIt-Anchor" href="#24-string中哪些特殊注意的"></a> 2.4 String()中哪些特殊注意的？</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串的拼接 + 会每个都是String()返回值相加</span></span><br><span class="line"><span class="string">''</span> + <span class="literal">undefined</span> + <span class="literal">null</span>; <span class="comment">// =&gt; "undefinednull"</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="literal">null</span>; <span class="comment">// =&gt; 这时候调用数字加，返回NaN</span></span><br><span class="line"><span class="comment">// 如果有toString方法，会返回其toString()方法的值</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>); <span class="comment">// =&gt; "undefined"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>); <span class="comment">// =&gt; "null"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">99</span>); <span class="comment">// =&gt; "99"</span></span><br><span class="line"><span class="built_in">String</span>([<span class="number">1</span>, <span class="literal">true</span>, &#123;&#125;]); <span class="comment">// 和toString()返回的一样=&gt; "1,true,[object Object]"</span></span><br></pre></td></tr></table></figure>
<h3 id="25-number中哪些特殊注意的"><a class="markdownIt-Anchor" href="#25-number中哪些特殊注意的"></a> 2.5 Number()中哪些特殊注意的？</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字 + 会是Number()返回值相加</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span>; <span class="comment">// =&gt; NaN, Number(undefined)为NaN</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>; <span class="comment">// =&gt; 1, Number(null)为0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">""</span>); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">" 1.23e-1 "</span>); <span class="comment">// =&gt; "0.123", 去字符串两端空格并尽量转换</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">"123a"</span>); <span class="comment">// =&gt; NaN</span></span><br><span class="line"><span class="comment">// 普通对象全是NaN</span></span><br><span class="line"><span class="built_in">Number</span>([]); <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">" 1.23e-1 "</span>]); <span class="comment">// =&gt; 0.123</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">"1"</span>, <span class="number">2</span>]); <span class="comment">// =&gt; NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// =&gt; 1511352731707</span></span><br></pre></td></tr></table></figure>
<h3 id="26-string-number中一个对象有什么规律"><a class="markdownIt-Anchor" href="#26-string-number中一个对象有什么规律"></a> 2.6 String()、Number()中一个对象有什么规律？</h3>
<ul>
<li>对象一般都先调用自己的 valueOf()方法，如果返回的是原始值，则基于这个原始值计算获得结果，如果 valueOf()方法返回是非原始值，则调用 toString()方法来获取原始值，然后计算获得结果！</li>
</ul>
<h3 id="27-全等运算符的一些规则"><a class="markdownIt-Anchor" href="#27-全等运算符的一些规则"></a> 2.7 ===全等运算符的一些规则？</h3>
<ul>
<li>如果两个值类型不相同，则它们不全等；</li>
<li>null、undefined、true、false 仅仅与自身全等；</li>
<li>NaN 与任何值都不全等，包括其本身，即 NaN === NaN 返回 false；</li>
<li>两个数字的数值相等，则其全等，即 0 === -0、Number.POSITIVE_INFINITY === Infinity 返回 true;</li>
<li>如果是对象，必须引用同一个对象才全等，否则不等；</li>
</ul>
<h3 id="28-相等运算符的一些规则"><a class="markdownIt-Anchor" href="#28-相等运算符的一些规则"></a> 2.8 ==相等运算符的一些规则？</h3>
<ul>
<li>如果两个值类型相同，则会遵循全等去返回结果，类型不同的双方，会先做一些转换变成同类型，再遵循照全等去返回结果；</li>
<li>null == undefined，除本身以及对方都不等；</li>
<li>如果一个是数字，另一个是字符串，会将字符串转换成数字（Number 方法），然后用转换后的值去进行比较，所以 0 == &quot;&quot;、 &quot;1.23e-1&quot; == 0.123 返回 true；</li>
<li>如果其中有一个是布尔值，则先将布尔值转换成 0 或 1，再按上述规则，所以&quot;0&quot; == false 返回 true；</li>
<li>如果其中有一个是对象，则先对象转换成原始值（先调用 valueOf()若返回不是原始值，则再调用 toString()），然后再按上述规则，所以[] == 0、[] == false 均返回 true；</li>
</ul>
<h3 id="29-和的返回规则-短路规则"><a class="markdownIt-Anchor" href="#29-和的返回规则-短路规则"></a> 2.9 &amp;&amp;和||的返回规则<code>---</code>短路规则</h3>
<ul>
<li>首先 JS 中的“假值”：false、null、undefined、0、-0、NaN、&quot;&quot;；</li>
<li>&amp;&amp;的短路：第一个操作数是“假值”，则返回第一个操作数，不再进行第二个操作数的计算，第一个为非“假值”，返回第二个操作数的结果，所以(null &amp;&amp; abc) === null、&quot;abc&quot; &amp;&amp; &quot;abcd&quot; === &quot;abcd&quot;；</li>
<li>||的短路：和&amp;&amp;相反，第一个为“假值”，则返回第二个操作数…</li>
</ul>
<h2 id="3-变量的声明提前是什么"><a class="markdownIt-Anchor" href="#3-变量的声明提前是什么"></a> 3. 变量的“声明提前”是什么？</h2>
<ul>
<li>变量的声明：变量的声明语句有两种，var 声明变量语句和 function 声明函数语句；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'abc'</span>; <span class="comment">// var声明变量语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// function声明函数语句，结尾不能有分号</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 匿名函数赋值给f，还是属于var声明变量语句</span></span><br><span class="line"><span class="comment">// 函数表达式中的函数声明的函数名称，仅仅在函数体内有效，不会进去命名空间</span></span><br><span class="line"><span class="keyword">var</span> vf = <span class="function"><span class="keyword">function</span> <span class="title">tf</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="keyword">typeof</span> tf)&#125;;</span><br><span class="line">vf(); <span class="comment">// "function"</span></span><br><span class="line">tf; <span class="comment">// 报错：Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>解释：变量在它们定义的脚本或者函数中的声明语句（但不涉及赋值）都被“提前”至脚本或者函数的顶部，优先级函数声明 &gt; 形参定义 &gt; 函数声明；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg1;</span><br><span class="line">    <span class="built_in">console</span>.log(arg1);        <span class="comment">// "abc"，形参的命名优先级大于声明语句</span></span><br><span class="line">    <span class="keyword">var</span> arg2 = <span class="string">"abcd"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arg2);        <span class="comment">// "abcd"，形参是可以被重新赋值取代的</span></span><br><span class="line">    <span class="built_in">console</span>.log(s);           <span class="comment">// "undefined"，不会throw ReferenceError</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> tf);   <span class="comment">// "function"，函数声明即定义了tf的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(vf);          <span class="comment">// "undefined"，仅仅算变量声明</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">'abc'</span>;</span><br><span class="line">    <span class="keyword">var</span> vf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tf</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">g(<span class="string">'abc'</span>, <span class="string">'abc'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="4-object"><a class="markdownIt-Anchor" href="#4-object"></a> 4. Object</h2>
<ul>
<li>对象的属性：分为“数据属性(data property)”和“存储器属性(accessor property)”；</li>
<li>数据属性就是一个简单的值（null，字符串，对象等都算普通值），其属性的特性有 value、writable、enumerable、configurable；</li>
<li>存储器属性的属性值是用 getter 和 setter 两个方法定义的，其属性的特性有 get、set、enumerable、configurable；</li>
<li>对象的继承：对象具有“自有属性”，也有一些从原型对象继承而来的属性，即“继承属性”；继承的方式主要是三种，第一种对象直接量的形式是直接继承了 Object.prototype 属性;构造函数形式生成的对象继承了其构造函数的 prototype 属性，而 Object.create()方法生成的对象继承了该方法的第一个参数（可以为 null，但不允许为 undefined）。我们通常把继承的属性称之为对象的“<strong>原型对象</strong>”；</li>
<li>对象的类：ES5 本身没有类，但是通常我们把构造函数的名字称之为类的名字，js 内置的就有 Array 类、RegExp 类、Date 类，Error 类等，如上我们就构造了一个 ConstructorFoo 的类；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造函数的方式实现对象的继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorFoo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">this</span>[p] = obj[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inheritObj = &#123;</span><br><span class="line">    <span class="attr">inheritP</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">ConstructorFoo.prototype = inheritObj;</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> ConstructorFoo(&#123;<span class="attr">p</span>:<span class="number">100</span>&#125;);</span><br><span class="line">son1.p; <span class="comment">// 100</span></span><br><span class="line">son1.inheritP; <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2. Object.create()方法实现对象的继承</span></span><br><span class="line"><span class="keyword">var</span> son2 = <span class="built_in">Object</span>.create(&#123;<span class="attr">inheritP</span>: <span class="number">2</span>&#125;);</span><br><span class="line">son2.inheritP; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象直接量和直接o.x=1这种设置的属性，writable、enumerable、configurable都默认为true，getOwnPropertyDescriptor只能查自有属性的属性特性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(son1, <span class="string">'p'</span>); <span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(son1, <span class="string">'inheritP'</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 如果用Object.defineProperty(ies)方法创建的属性，则未设置的都默认为数据属性，value为undefined，其余为false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(son1, <span class="string">'a'</span>, &#123;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(son1, <span class="string">'a'</span>); <span class="comment">// &#123;value: undefined, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="comment">//ES3中定义一个存储器属性，（IE以外）都已经实现的get和set写法，其中写法不能为get next: function()...。getter和setter中的this为对象本身。</span></span><br><span class="line"><span class="keyword">var</span> serialnum = &#123;</span><br><span class="line">    <span class="attr">$n</span>: <span class="number">0</span>,</span><br><span class="line">    get next() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$n++&#125;,</span><br><span class="line">    set next(n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="keyword">this</span>.$n) <span class="keyword">this</span>.$n = n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="string">"序列号的值不能比当前值小"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ES5中定义一个存储器属性，自然就是用Object.defineProperty(ies)方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(son1, &#123;</span><br><span class="line">    <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumeable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="attr">y</span>: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumeable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="attr">r</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x*<span class="keyword">this</span>.x + <span class="keyword">this</span>.y*<span class="keyword">this</span>.y) &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个属性是否存在于对象中，是其自有属性还是继承属性？</span></span><br><span class="line"><span class="comment">// 1. in运算符</span></span><br><span class="line"><span class="string">'p'</span> <span class="keyword">in</span> son1; <span class="string">'inheritP'</span> <span class="keyword">in</span> son1; <span class="comment">// 皆true,</span></span><br><span class="line"><span class="comment">// 2. 对象的继承方法hasOwnProperty，仅仅是自有属性才返回true</span></span><br><span class="line">son1.hasOwnProperty(<span class="string">'inheritP'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 3. for/in循环遍历了对象自有属性和继承属性中所有可枚举(enumerable为true)的属性</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> son1) <span class="built_in">console</span>.log(p); <span class="comment">// p inheritP</span></span><br><span class="line"><span class="comment">// 4. 对象的继承方法propertyIsEnumerable，仅当是自有属性且是可枚举的返回true</span></span><br><span class="line">son1.propertyIsEnumerable(<span class="string">'inheritP'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象的原型对象</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(son1); <span class="comment">// &#123; inheritP: 1 &#125;</span></span><br><span class="line">inheritObj.isPrototypeOf(son1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(son1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="5-array"><a class="markdownIt-Anchor" href="#5-array"></a> 5. Array</h2>
<ul>
<li>数组的最后一个逗号和对象是一样的，可以省略，所以其 length 的判断要注意；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[,].length; <span class="comment">// 1</span></span><br><span class="line">[<span class="number">1</span>,,<span class="number">3</span>].length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于数组是对象生成的子类，所以[]里的不止可以是数组索引，还可以是字符串，但是仅仅[]中的值和一个数字非负整数相等或者是非负整数的字符串，才会计入数组的队列中，有可能修改其 length，其余的都当做普通属性处理；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">-1.23</span>] = <span class="literal">true</span>; <span class="comment">// 创建了一个名为"-1.23"的属性</span></span><br><span class="line">a[<span class="string">'1000'</span>] = <span class="literal">true</span>; <span class="comment">// 数组的第1001个元素为true</span></span><br><span class="line">a[<span class="number">1.000</span>] = <span class="number">1</span>; <span class="comment">// 数组的第二个元素，和a[1]相等</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype 上给所有数组实例继承的方法可分为三类，一类是不改变数组本身的，主要依赖其 return 值来获取新的结果，包括 join、concat、slice、indexOf、lastIndexOf；另一类是改变了数组本身的，包括 reverse、sort、splice、push、pop、unshift、shift；还有 ES5 新增的 forEach、map、filter、every、some、reduce、reduceRight；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join方法不传参默认为逗号，它会将每个元素先转化成字符串再用参数的字符去连接</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].join(); <span class="comment">// "1,2,c"</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="string">'c'</span>]].join(<span class="string">'__'</span>); <span class="comment">// "1__2,c"</span></span><br><span class="line">[,,].join(<span class="string">'__'</span>); <span class="comment">// "__"</span></span><br><span class="line">[<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'__'</span>); <span class="comment">// "__"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// concat方法支持传多个参数，参数可以是数组和非数组，当时数组时会将其每个都加入而非整体，非数组直接加到后面</span></span><br><span class="line">[<span class="number">1</span>].concat(<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]); <span class="comment">// [1, 2, 3, 4, 5, [6, 7]];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice方法将数组的一部分返回回来，两个参数分别表示起点和终点，返回的结果不包括终点；若忽略第二个参数，默认表示到结尾</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">a.slice(<span class="number">3</span>,<span class="number">2</span>); <span class="comment">// []</span></span><br><span class="line">a.slice(<span class="number">2</span>); <span class="comment">// [3, 4, 5]</span></span><br><span class="line">a.slice(<span class="number">0</span>,<span class="number">-1</span>); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf和lastIndexOf查找(全等匹配)数组中某个元素的索引值，查找到第一个就返回不再查找，若查找失败则返回-1，lastIndexOf从数组末尾查，这个方法在数组和字符串的效果是一样的，且可以传第二个参数来表示查找位置</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">a.indexOf(<span class="number">3</span>); <span class="comment">// 2</span></span><br><span class="line">a.lastIndexOf(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">a.indexOf(<span class="number">5</span>); <span class="comment">// 4</span></span><br><span class="line">a.indexOf(<span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 4</span></span><br><span class="line">a.indexOf(<span class="number">5</span>, <span class="number">5</span>); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort方法是将数组排序，默认会以字母表顺序排序（排序本身没说明就是以小到大），可以传一个函数，假如第一个参数在前则返回小于0的数值，反之返回大于0的数值</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort(); <span class="comment">// 返回新的a，此时a为[1111, 222, 33, 4]</span></span><br><span class="line">a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">pre, next</span>) </span>&#123; <span class="keyword">return</span> pre - next&#125; ); <span class="comment">// [4, 33, 222, 1111]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice方法是将数组指定位置增删的方法，第一个参数表示起点，第二个参数表示准备删除元素的个数，后面的参数是准备增加新元素，返回的是被删除元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">a.splice(<span class="number">4</span>); <span class="comment">// 返回[5, 6, 7, 8]; a现在是[1, 2, 3, 4]</span></span><br><span class="line">a.splice(<span class="number">-1</span>); <span class="comment">// 返回[4]; a现在是[1, 2, 3]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 返回[2, 3]; a现在是[1]</span></span><br><span class="line">a.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 返回[]; a现在是[3, 2, 1]</span></span><br><span class="line">a.splice(<span class="number">1000</span>, <span class="number">5</span>, <span class="number">0</span>); <span class="comment">// 返回[]; a现在是[3, 2, 1, 0]; 若起点大于length，则为数组末尾进行删增操作</span></span><br><span class="line">a.splice(<span class="number">-1000</span>, <span class="number">5</span>, <span class="number">0</span>); <span class="comment">// 返回[3, 2, 1, 0]; a现在是[0]; 若起点小于-length，则为数组开头进行删增操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach方法的参数function的三个参数value, index, array，其中value是array[index]全等的，但是修改其相当于ES6的const定义，不可重新赋值</span></span><br><span class="line"><span class="keyword">var</span> a = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">y</span>:<span class="number">2</span> &#125;];</span><br><span class="line">a.forEach(<span class="function">(<span class="params">v, i ,a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v === a[i]);</span><br><span class="line">&#125;);                            <span class="comment">// true, true</span></span><br><span class="line">a.forEach(<span class="function">(<span class="params">v, i ,a</span>) =&gt;</span> &#123;</span><br><span class="line">    v.x &amp;&amp; (v.x = <span class="number">2</span>);</span><br><span class="line">&#125;)                            <span class="comment">// a现在是[&#123; x: 2 &#125;, &#123; y:2 &#125;]</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.forEach(<span class="function">(<span class="params">v, i ,a</span>) =&gt;</span> &#123;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;)                           <span class="comment">// a现在仍是[1, 2, 3, 4, 5]</span></span><br><span class="line">a.forEach(<span class="function">(<span class="params">v, i ,a</span>) =&gt;</span> &#123;</span><br><span class="line">    a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;)                           <span class="comment">// a现在是[2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array 构造函数上的方法，Array.isArray()，判断是否是数组</li>
</ul>
<h2 id="6-function"><a class="markdownIt-Anchor" href="#6-function"></a> 6. Function</h2>
<ul>
<li>变量的作用域：指的是变量可以被引用的区域。C 语言类的编程语言都是有块级作用域的，即花括号{}内的代码具有各自的作用域，变量在声明它们之外的代码里是不可见的。<strong>JavaScript 没有块级作用域，取而代之的是函数作用域。</strong> 函数作用域顾名思义就是函数块里形成一个外界不可见的作用域。全局变量在程序中始终都是有定义的，局部变量在声明它的函数体内以及所嵌套的函数体内是有定义的。</li>
<li>全局对象和局部对象：JavaScript 的全局变量实际上是全局对象的一个属性，ES5 把全局对象称为“声明上下文对象”。全局对象可以通过 this 关键字来引用。而局部对象可以说是函数作用域内的存储着局部变量的一些属性，局部对象是我们不可见的内部实现。</li>
<li>词法作用域：也叫静态作用域，它的作用域是指在词法分析（定义）阶段就确定了，不会改变。</li>
<li>作用域链：每一个局部作用域都会产生一个与之关联的作用域链，可以把它看作一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。在 JavaScript 最顶层代码中，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象（即局部对象），第二个是全局对象；在一个嵌套的函数体内，作用域链上至少有三个对象。<strong>在定义一个函数时，实际上保存着一个作用域链。</strong></li>
<li>这一块还是看一下大神的文章比较清晰：<a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="external">https://github.com/mqyqingfeng/Blog/issues/3</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo在定义成，其</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 会输出2还是3？</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  foo();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a++); <span class="comment">// 会输出2还是3？</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// 2 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数定义的两种方式：函数表达式和函数声明语句。<strong>函数名和形参只是函数内部的一个局部变量。</strong> 函数表达式也可以包含函数名称的变量有声明提前，但是真正的赋值仍是没有提前的，所以必须在赋值语句之后才能调用，而函数声明语句会声明提前，相当于在作用域顶部就定义了 var fooName = function fooName(){…}，所以函数声明语句无论在作用域的什么地方定义，其调用都是可以在作用域的任何地方。值得注意的是，函数声明语句不能出现在循环、条件判断或者 try/catch/finally 的语句中。</li>
<li>函数调用的四种方式，以及每种方式中函数体内的 this 关键字的指代。若是 bind 方法绑定过的函数，则无论怎样调用方式，其值仍是 bind 的那个对象。但是需要注意的是 bind 方法不会改变原函数，而会返回一个绑定后的新函数！具体见示例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 作为函数直接调用，非严格模式下this是全局变量，严格模式下是undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnA</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a; &#125;;</span><br><span class="line">returnA(); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2. 作为方法，this是其调用的对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">myMethod</span>: returnA &#125;;</span><br><span class="line">obj.myMethod(); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3. 作为构造函数，也就是new之后去调用，this只带一个初始化的空对象，见之前“new一个构造函数，实际做了什么？”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 通过call()和apply()方法间接调用，this是第一个参数</span></span><br><span class="line"><span class="keyword">var</span> anotherObj = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;;</span><br><span class="line">returnA.call(anotherObj);  <span class="comment">// 3</span></span><br><span class="line">obj.myMethod.call(anotherObj); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综合示例1</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);      <span class="comment">// true，this</span></span><br><span class="line">        f();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);  <span class="comment">// false，this在浏览器环境下是window</span></span><br><span class="line">            <span class="built_in">console</span>.log(self === o);  <span class="comment">// true，闭包</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.m(); <span class="comment">// 输出如上</span></span><br><span class="line"><span class="comment">// call方法的运用</span></span><br><span class="line"><span class="keyword">var</span> outer = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === outer);</span><br><span class="line">        f();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.m.call(outer);  <span class="comment">// true, true</span></span><br><span class="line"><span class="comment">//  bind无法直接在函数声明语句后加</span></span><br><span class="line"><span class="keyword">var</span> outer1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">m</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === outer2);</span><br><span class="line">        f();</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === outer1);</span><br><span class="line">        &#125;).bind(outer1)</span><br><span class="line">    &#125;).bind(outer2)</span><br><span class="line">&#125;;</span><br><span class="line">o.m.call(outer);  <span class="comment">// 语法报错！</span></span><br><span class="line"><span class="comment">// bind对于原函数无影响，会返回一个绑定this后的函数，且不受call方法影响！</span></span><br><span class="line"><span class="keyword">var</span> outer1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">m</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === outer2);</span><br><span class="line">        f.bind(outer1);</span><br><span class="line">        f();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === outer1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> g = f.bind(outer1);</span><br><span class="line">        g();</span><br><span class="line">    &#125;).bind(outer2)</span><br><span class="line">&#125;;</span><br><span class="line">o.m.call(outer) <span class="comment">// true true false false true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数的 arguments----函数内指向<strong>实参对象的引用</strong>(所以改变 arguments 也会改变实参，反之亦然)。它是一个类数组对象。它还有两个属性，callee 属性指代当前正在执行的函数，caller 指向正在执行的函数的函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">0</span>); <span class="comment">// 0 0 1 1 2 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">factorial</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.factorial(<span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<ul>
<li>匿名函数：由于函数形成的代码块形成了一个局部作用域，所以有的时候为了怕对全局代码造成变量污染，匿名函数就显得特别常见。(function(){…}())。闭包和匿名函数一起可以实现对于局部变量的保存。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从0开始，每次运行一次就加1；</span></span><br><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> counter++ &#125;;</span><br><span class="line">&#125;());</span><br><span class="line">uniqueInteger(); <span class="comment">// 0;</span></span><br><span class="line">uniqueInteger(); <span class="comment">// 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，每个函数都</span></span><br><span class="line"><span class="keyword">var</span> func = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    func[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> i &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">func[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">func[<span class="number">1</span>](); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数的 length 属性：表示函数形参的个数，而 arguments 的 length 表示实参的个数</li>
</ul>
<h2 id="7-类和模块"><a class="markdownIt-Anchor" href="#7-类和模块"></a> 7. 类和模块</h2>
<ul>
<li>类：ES6 之前，JS 没有类的概念，但是是可以实现类。类的实现是基于其原型继承机制的，如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例，所以原型对象是类的唯一标识。</li>
<li>构造函数：构造函数是“类”的外在表现，构造函数的名字通常用作类名，比如 Range()构造函数创建了 Range 类的对象。</li>
<li>instanceof：检查一个对象是不是属于某个类或者其子类，比如</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range();</span><br><span class="line">r <span class="keyword">instanceof</span> Range; <span class="comment">// true;</span></span><br><span class="line">r <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true，因为Range是Object的子类</span></span><br></pre></td></tr></table></figure>
<h2 id="8-正则表达式"><a class="markdownIt-Anchor" href="#8-正则表达式"></a> 8. 正则表达式</h2>
<ul>
<li>字符：JavaScript 采用 UTF-16 编码的 Unicode 字符集，JavaScript 字符串是由一组无符号的 16 位值组成的序列。</li>
<li>创建：正则表达式直接量创建<code>/\d/</code>，或者 RegExp 构造函数创建 <code>new RegExp('\\\d')</code>。在 ES3 中，除 IE 外的其他浏览器全都对于正则表达式直接量创建的是共享一个实例，ES5 修正这种不合理。</li>
<li>正则表达式中的特殊意义字符：<code>^ $ . ? * + = ! : | \ / ( ) [ ] { }</code></li>
<li>当启用重复模式时，默认是“贪婪匹配”，如要非贪婪匹配，需要在重复字符后加一个?即可</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>匹配规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>[…]</td>
<td>方括号内任意字符</td>
<td><code>'abc'.match(/[a-z]/g)</code> 结果 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></td>
</tr>
<tr>
<td>[^…]</td>
<td>不在方括号内的任意字符</td>
<td><code>'abc!'.match(/[^\!]/g)</code> 结果 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></td>
</tr>
<tr>
<td>.</td>
<td>除换行符合其他 Unicode 终止符的任意字符</td>
<td><code>'abc!\n'.match(/./g)</code> 结果 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;!&quot;]</code></td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母、数组和下划线，等价于<code>[_a-zA-Z0-9]</code></td>
<td><code>&quot;i don't&quot;.match(/\w/g)</code> 结果 <code>[&quot;i&quot;, &quot; &quot;, &quot;d&quot;, &quot;o&quot;, &quot;n&quot;, &quot;t&quot;]</code></td>
</tr>
<tr>
<td>\W</td>
<td>\w 的逆运算</td>
<td><code>&quot;i don't&quot;.match(/[^\w]/g)</code> 结果 <code>[&quot;'&quot;]</code></td>
</tr>
<tr>
<td>\s</td>
<td>任何 Unicode 空白符</td>
<td><code>&quot;i don't\n&quot;.match(/\s/g)</code> 结果 <code>[&quot; &quot;, &quot;\u000A&quot;]</code></td>
</tr>
<tr>
<td>\d</td>
<td>任何 ASCII 数字，等价于[0-9]</td>
<td><code>&quot;1.23&quot;.match(/\d/g)</code> 结果 <code>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code></td>
</tr>
<tr>
<td>\D</td>
<td>\d 的逆运算</td>
<td></td>
</tr>
<tr>
<td>{m,n}</td>
<td>m ≤ 匹配前一项 ≤ n， 切记逗号后不能有空格！</td>
<td><code>/\d{2,3}/.exec('1234')</code> 结果 <code>[&quot;123&quot;]</code></td>
</tr>
<tr>
<td>{m,}</td>
<td>匹配前一项 ≥ m</td>
<td><code>/\d{1,}/.exec('1234')</code> 结果 <code>[&quot;1234&quot;]</code></td>
</tr>
<tr>
<td>{m}</td>
<td>匹配前一项 = m</td>
<td></td>
</tr>
<tr>
<td>？*+</td>
<td>?是{0,1} *是{0,} +是{1,}</td>
<td><code>/\d+?/.exec('1234')</code> 结果 <code>[&quot;1&quot;]</code></td>
</tr>
<tr>
<td>(…)</td>
<td>组合，将几个项组合成一个单元，这个单元可通过*、+、？、|等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后引用和使用</td>
<td><code>/(\d){3}aaa/.exec('222aaas')</code> 结果 <code>[&quot;222aaa&quot;, &quot;2&quot;]</code></td>
</tr>
<tr>
<td>|</td>
<td>选择，匹配的是该符号左边的子表达式或右边的子表达式</td>
<td><code>/(ab\|cd)o|abcd/</code>可以匹配出 abo、cdo、abcd</td>
</tr>
<tr>
<td>(?:…)</td>
<td>只组合，把项组合成一个单元，但不记忆与该组相匹配的字符</td>
<td></td>
</tr>
<tr>
<td>\n</td>
<td>和第 n 个分组第一次匹配的字符相匹配</td>
<td><code>/(['&quot;])[^\1]*\1/</code>可以匹配成对的单引号或者双引号</td>
</tr>
<tr>
<td>^和$</td>
<td>匹配字符串的开头和结尾，在多行检测中检测一行的开头的结尾</td>
<td><code>/^abc$/</code>仅仅匹配 abc</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的边界</td>
<td><code>/\bjava\b/.test(java is bad)</code>为 true，<code>/\bjava\b/.test('javascript')</code>为 false</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词的边界</td>
<td><code>/\Bjava\B/.test('javascript')</code>为 true</td>
</tr>
<tr>
<td>(?=p)</td>
<td>零宽正向先行断言</td>
<td><code>/java(?=\:)/.exec('java: good')</code>结果为<code>[&quot;java&quot;]</code></td>
</tr>
<tr>
<td>(?!p)</td>
<td>零宽负向先行断言</td>
<td><code>/java(?!\:)/.exec('java is good')</code>结果为<code>[&quot;java&quot;]</code>，<code>/java(?!$)/.exec('i love java')</code>结果为 null</td>
</tr>
</tbody>
</table>
<ul>
<li>String 类型中可以用正则当参数的方法有 search、replace、match、split。</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>替换</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>匹配第 n(1,2,3…)个 regexp 中的圆括号字表达式的文本</td>
</tr>
<tr>
<td>$&amp;</td>
<td>匹配结果</td>
</tr>
<tr>
<td>$`</td>
<td>匹配结果的左边文本</td>
</tr>
<tr>
<td><code>$'</code></td>
<td>匹配结果的右边文本</td>
</tr>
<tr>
<td>$$</td>
<td>美元符号$</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search方法不支持全局搜索，返回最先匹配到的下标值或者-1</span></span><br><span class="line"><span class="string">"JavaScript"</span>.search(<span class="regexp">/srcipt/i</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// replace方法主要是第二个参数，若为字符串支持$n、$&amp;、$`、$'、$$，还支持函数</span></span><br><span class="line"><span class="string">`i say: "hello!"`</span>.replace(<span class="regexp">/(["'])([^\1]*)\1/</span>, <span class="string">"$&amp; yes"</span>) <span class="comment">// `"i say: "hello!" yes`</span></span><br><span class="line"><span class="string">`i say: "hello!"`</span>.replace(<span class="regexp">/(["'])([^\1]*)\1/</span>, <span class="string">"$1 yes"</span>) <span class="comment">// `i say: " yes`</span></span><br><span class="line"><span class="string">`i say: "hello!"`</span>.replace(<span class="regexp">/(["'])([^\1]*)\1/</span>, <span class="string">"'$2' yes"</span>) <span class="comment">// `i say: 'hello!' yes`</span></span><br><span class="line"><span class="string">`i say: "hello!"`</span>.replace(<span class="regexp">/(["'])([^\1]*)\1/</span>, <span class="string">`"$3 yes"`</span>) <span class="comment">// `i say: "$3 yes"`</span></span><br><span class="line"><span class="string">`i say: "hello!"`</span>.replace(<span class="regexp">/(["'])([^\1]*)\1/</span>, <span class="string">"$$3"</span>) <span class="comment">// "i say: $3"</span></span><br><span class="line"><span class="comment">// match方法是最常用的，若参数正则带g，则返回全局匹配所有匹配结果，否则返回匹配第一个的结果和子结果的集合组数，若为返回null</span></span><br><span class="line"><span class="string">"1 plus 2 equals 3"</span>.match(<span class="regexp">/\d/g</span>) <span class="comment">// ["1", "2", "3"]</span></span><br><span class="line"><span class="string">"my blog at https://www.github.com/dengxy#blog"</span>.match(<span class="regexp">/(\w+)\:\/\/([\w\.]+)\/(\S*)/</span>)<span class="comment">// ["https://www.github.com/dengxy#blog", "https", "www.github.com", "dengxy#blog"]</span></span><br><span class="line"><span class="comment">// split指定分隔符</span></span><br><span class="line"><span class="string">"1, 2，3,4,,5"</span>.split(<span class="regexp">/[,，\s]+/</span>) <span class="comment">// ["1", "2", "3", "4", "5"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>RegExp 的属性和方法</p>
<ol>
<li>exec 方法，若参数带有 g，则会将正则表达式的 lastIndex 属性设置为紧挨着匹配子串的字符位置，然后下一次的调用就会从该位置开始去匹配字符串，每次若有返回结果返回匹配结果和子串的数组集合，若没有匹配结果则返回 null，且将 lastIndex 重置为 0。若不带有 g，lastIndex 永远都是 0，会从起始位置开始匹配。</li>
<li>test 方法，和 exec 同等的过程，只是返回结果 exec 若返回非 null 则其返回 true，否则返回 false。</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>source</td>
<td>String，只读，正则表达式的文本</td>
</tr>
<tr>
<td>global</td>
<td>Boolean，只读，表明正则表达式是否带有修饰符 g</td>
</tr>
<tr>
<td>ignoreCase</td>
<td>Boolean，只读，表明正则表达式是否带有修饰符 i</td>
</tr>
<tr>
<td>multiline</td>
<td>Boolean，只读，表明正则表达式是否带有修饰符 m</td>
</tr>
<tr>
<td>lastIndex</td>
<td>Number，可读写，表示正则表达式下次检索的开始位置</td>
</tr>
</tbody>
</table>
<ul>
<li>练习题
<ol>
<li>写一个函数 getCamelCase，将当前传入的 string 由-连接式变成驼峰命名法则。</li>
<li>写一个函数 getQuery，获取当前 URL 的查询参数并返回一个对象，同一个查询参数若有多个值则封装成数组。若没有返回{}。</li>
<li>写一个函数 testIPV4，检测当前字符串是否为合法的 ipv4 地址（0.0.0.0~255.255.255.255）。</li>
<li>写一个函数 getMostFrequentWord，检测一篇文章中英文单词出现次数最多的单词和其次数。</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCamelCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/-(\w)/g</span>, ($, $<span class="number">1</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">1.</span>toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> search = <span class="built_in">decodeURI</span>(location.search);</span><br><span class="line">    <span class="keyword">const</span> pattern = <span class="regexp">/\??(\w+)=(\w+)&amp;?/g</span>;</span><br><span class="line">    <span class="keyword">const</span> query = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">while</span>((res = pattern.exec(search)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> v = query[res[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">if</span>(v) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(v)) &#123;</span><br><span class="line">                v.push(res[<span class="number">2</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                query[res[<span class="number">1</span>]] = [v, res[<span class="number">2</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            query[res[<span class="number">1</span>]] = res[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pattern = <span class="regexp">/^([1-9]|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.([1-9]|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.([1-9]|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.([1-9]|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/</span>;</span><br><span class="line">    <span class="keyword">return</span> pattern.test(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMostFrequentWord</span>(<span class="params">article</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> allWords = article.match(<span class="regexp">/\b[\w']+\b/gmi</span>);</span><br><span class="line">    <span class="keyword">const</span> countObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = allWords.length;i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> curWord = allWords[i];</span><br><span class="line">        <span class="keyword">if</span> (curWord <span class="keyword">in</span> countObj) &#123;</span><br><span class="line">            ++countObj[curWord];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countObj[curWord] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> frequency = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> mostFrequentWord = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> countObj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(countObj[key] &gt; frequency) &#123;</span><br><span class="line">            frequency = countObj[key];</span><br><span class="line">            mostFrequentWord = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        mostFrequentWord,</span><br><span class="line">        frequency</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-window-对象"><a class="markdownIt-Anchor" href="#9-window-对象"></a> 9. Window 对象</h2>
<ul>
<li>setTimeout 和 setInterval，用于异步指定时间执行的，返回的值可以供 clearTimeout 和 clearInterval 当做参数去取消后续函数的调用。</li>
<li>location 对象，表示当前窗口中当前显示的文档 URL，并且提供方法使窗口载入新的文档。
<ol>
<li>href 属性：包含 URL 的完整文本，如<code>https://www.baidu.com/wenku/index.html?q=Javascript&amp;user=dengxy#results</code></li>
<li>protocol 属性：协议，<code>&quot;https&quot;</code>或者<code>&quot;http&quot;</code></li>
<li>hostname 属性: 主机名，如上是<code>&quot;www.baidu.com&quot;</code></li>
<li>port 属性：端口部分，如上是&quot;&quot;</li>
<li>host 属性: 主机名+端口部分。比如<code>&quot;www.baidu.com:8080&quot;</code></li>
<li>pathname 属性：路径名部分，如上是<code>&quot;/wenku/index.html&quot;</code></li>
<li>search 属性：查询部分，如上是<code>&quot;?q=Javascript&amp;user=dengxy&quot;</code></li>
<li>hash 属性：hash 值部分，如上是<code>&quot;#results&quot;</code></li>
<li>origin 属性：只读，域名的标准形式，如上是<code>&quot;https://www.baidu.com&quot;</code></li>
<li>assign 方法：载入指定 url，如 location.assign(’/wangpai/index.html’)会自动把 URL 的 pathname 以及后面的替换，location.assign('<a href="https://www.baidu.com" target="_blank" rel="external">https://www.baidu.com</a>')会把整个 URL 替换。</li>
<li>replace 方法：也是载入指定 url，但是在载入新文档之前会从浏览历史中把当前文档删除。</li>
<li>reload 方法：浏览器重新载入当前文档。</li>
<li>location 直接赋值：虽然 location 本身是对象，但是仍可以赋值一个 url 方式实现跳转，和虽然这个 assign 方法一样的效果，但是仍很扯。</li>
</ol>
</li>
<li>history：back、forward 方法来前进和后退，go()支持传参一次前进和后退任意多个页面</li>
<li>iframe 产生的多个独立的 window 对象，每一个都有一个 self 引用于自己的 window。top 表示最顶层的 window 对象，parent 表示当前窗体的父窗口，所以在顶层窗口肯定是 <code>self===top===parent</code> 的。iframe 的 window 引用也有多种途径，可以通过 frame[0]、frame[1]分别引用当前窗口第 1 个和第二个子窗体的 window 对象，也可以通过 frame[子窗体的 name/子窗体的 id]这样。还可以通过 iframe 的 DOM 元素 contenWindow 属性。</li>
</ul>
<h2 id="10-document-对象"><a class="markdownIt-Anchor" href="#10-document-对象"></a> 10. document 对象</h2>
<ul>
<li>
<p>获取元素的原生 JS 方法：</p>
<ol>
<li>document.getElementById 返回的是一个 Element 对象实例，若未查找到则返回 null；</li>
<li>document.getElementsByName/getElementsByTagName/getElementsByClassName 返回的是 NodeList 对象实例，是 Element 对象实例的集合。无论是 Element 对象还是 NodeList 对象都和 document 实时挂钩，所以每一次的读写都是实时地获取或操作文档，尤其是 NodeList 对象每次都会重新更新其内容，比如 const aDom = document.getElementsByTagName('a');将 document 中再加一个 a 元素，aDom 也会更新成包括新加的列表 。所以一般的，把 NodeList 对象转化成普通数组以便调用，Array.prototype.slice.call(nodelist);</li>
<li>document.querySelector/querySelectorAll 支持传参和 css 选择器语法保持一致，所以异常强大，如 document.querySelector(’#id’), document.querySelectorAll('p[lang=&quot;fr&quot;]');但是 querySelectorAll 其返回的是查询是 document 的快照结果，不会实时更新。</li>
</ol>
</li>
<li>
<p>元素节点对象上一些有用的属性：</p>
<ol>
<li>自己在 DOM 树中一些位置相关属性：如 parentNode 表示其父节点元素，childNodes 表示其子节点的实时表示的 NodeList 对象，firstChild/lastChild 分别为子节点的第一个/最后一个，nextSibling/previoursSibling 分别表示其兄弟节点的下一个/上一个，nodeType 表示其节点类型(9 表示 document 节点，1 表示 Element 节点，3 表示 Text 节点等)，nodeValue 表示 Text 节点或 Comment 节点的内容</li>
<li>实际上只是关心 Element 节点的 API：children 表示子节点中仅仅是 Element 节点的列表，同理还有 firstElementChild/lastElementChild/nextElementSibling/previousElementSibling</li>
<li>元素的标准 HTML 属性和非标准 HTML 属性：元素本身有一些通用的属性，如 id、name、className、style 等每个元素设置都有作用的，注意 id 是全局唯一的，且设置后立即会变成全局属性放 window 下，style 属性是一个对象，而有些元素是例如一个 script 标签元素或者 a 标签元素，其 src 属性是该标签很重要的属性，radio/checkbox 类型的 input 类型其 name、type、defaultChecked 和 checked 属性，需要注意的是所有的属性都会有一个转化，如 max-length 转化成属性变成了 maxLength。元素的非标准属性，如在 div 上加一个 max-length 属性，该元素对象的 maxLength 其实是无法获取到的，可以借助 getAttribute、setAttribute、hasAttribute 和 removeAttribute 方法，它们可以获取和设置标准属性和非标准属性，但是 getAttribute 和标准属性获取的结果不同的是它们返回的结果是字符串，而标准属性获取到的可以是布尔值(defaultChecked、checked)、数值(maxLength)、字符串(id、name、type)甚至对象(style)。</li>
<li>HTML5 的标准 data 属性获取和设置：dataset 属性，如 data-x=“0”的获取是 Element.dataset.x，返回的也是字符串不能是其他类型的值，若想删除某个 data 属性，可以 delete Element.dataset.x 即可删除该属性。注意的是带连字符的属性对应于驼峰命名法，如 data-jquery-test 属性就变成了 dataset.jqueryTest 属性。</li>
<li>元素的内容属性：例&lt;p id=&quot;test&quot;&gt;我是一个&lt;i&gt;好&lt;/i&gt;人&lt;/p&gt;，则 test.innerHTML 属性结果返回&quot;我是一个&lt;i&gt;好&lt;/i&gt;人&quot;，test.outerHTML 属性结果为&quot;&lt;p id=&quot;test&quot;&gt;我是一个&lt;i&gt;好人&lt;/p&gt;&quot;，test.textContent 属性结果为&quot;我是一个好人&quot;，而且这些属性都是可读写的。尤其有意思的是 innerHTML 和 textContent 的区别，test.innerHTML=&quot;我是一个&lt;i&gt;好&lt;/i&gt;人&quot;，元素没有更改，但是 test.textContent=&quot;我是一个&lt;i&gt;好&lt;/i&gt;人&quot;，元素会显式地出现&lt;i&gt;和&lt;/i&gt;，所以 textContent 属性有利于防止 xss 攻击。</li>
</ol>
</li>
<li>
<p>document 对象的方法：</p>
<ol>
<li>对 DOM 节点的操作：元素的创建涉及 document.createElement/createTextNode/createDocumentFragment 方法，其中 createDocumentFragment 的特殊之处在于它使得一组节点被当做一个节点看待：如果其当做参数传到 appendChild()、insetBefore()中，其实是将该文档片段的所有<strong>子节点</strong>插入到文档中，而非片段本身。</li>
<li>元素的插入和删除：元素的插入涉及 appendChild、insetBefore 方法，它们的第一个参数都是要插入的元素，insetBefore 方法必须传第二个参数，表示要传插入哪位元素前面。若调用的是一个已经存在文档中的节点，那么那个节点会自动从它当前位置删除并在新的位置重新插入。removeChild 和 replaceChild 都是在父元素上调用。</li>
</ol>
</li>
<li>
<p>练习题</p>
<ol>
<li>写一个函数 setMask,为元素加一个蒙层，使其有 opacity 的不透明度且点击无反应。</li>
<li>写一个函数 appendToBody ipv4 地址（0.0.0.0~255.255.255.255）。</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMask</span>(<span class="params">dom, opacity</span>) </span>&#123;</span><br><span class="line">    dom.style.position = <span class="string">'relative'</span>;</span><br><span class="line">    <span class="keyword">const</span> maskDom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    maskDom.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">    maskDom.style.top = <span class="number">0</span>;</span><br><span class="line">    maskDom.style.left= <span class="number">0</span>;</span><br><span class="line">    maskDom.style.width =<span class="string">`<span class="subst">$&#123;dom.clientWidth&#125;</span>px`</span>;</span><br><span class="line">    maskDom.style.height =<span class="string">`<span class="subst">$&#123;dom.clientHeight&#125;</span>px`</span>;</span><br><span class="line">    maskDom.style.backgroundColor =<span class="string">`rgba(0,0,0,<span class="subst">$&#123;opacity&#125;</span>)`</span>;</span><br><span class="line">    maskDom.addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125;);</span><br><span class="line">    dom.appendChild(maskDom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendToBody</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ulDom = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">1001</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.textContent = i;</span><br><span class="line">        frag.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    ulDom.appendChild(frag);</span><br><span class="line">    ulDom.addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.target === e.currentTarget) <span class="keyword">return</span>;</span><br><span class="line">        alert(e.target.textContent);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-浏览器事件"><a class="markdownIt-Anchor" href="#11-浏览器事件"></a> 11. 浏览器事件</h2>
<ul>
<li>浏览器事件传播的三个阶段：第一阶段：事件捕获阶段，是指浏览器从根元素开始一直从 DOM 往下到目标对象的事件处理过程(对应于 addEventListener 第三个参数为 true)；第二阶段，目标对象处理阶段，是目标对象本身的事件处理程序；第三阶段，事件冒泡阶段，指事件又会从目标元素到根元素的冒泡事件处理过程(对应于 addEventListener 第三个参数为 false 或者不传)。</li>
<li>事件注册与注销：现代浏览器所有的文档元素都有一个标准方法 addEventListener，其第一个参数为事件名称（click, mouseenter），第二个参数为 Function，第三个参数定义事件是否是在事件捕获阶段，不传为相当于 false 即在事件冒泡阶段，相应的注销函数为 removeEventListener。IE9 之前不支持 addEventListener 和 removeEventListener，也不支持事件捕获，相对应提供了 attachEvent 和 detachEvent 方法，但是其第一个参数要加 on（onclick, onmouseover）。</li>
<li>事件处理函数：addEventListener 的第二个参数为函数，其默认有一个参数为 event 对象，其 type 属性即为事件的名称，函数的 this===e.currentTarget，表示当前捕获或者冒泡到的元素对象，而 e.target 则为事件的触发元素，如子元素 li 触发的 click，冒泡到父元素 ul，则 e.target 是 li，e.currentTarget 是 ul。</li>
<li>阻止事件默认行为和阻止事件传播：有一些事件会触发浏览器的默认操作，可以通过上面说的事件处理函数的参数 event 调用 preventDefault 方法来取消默认行为，而 IE9 之前则是将 returnValue 属性设置为 false。阻止事件传播可以调用 stopPropagation 方法，它可以工作在事件传播的三个阶段的任意一个阶段，如在目标元素的事件捕获阶段中调用，则目标子元素都无法触发捕获事件捕获就相当于不会触发事件本身了。IE9 之前是 cancelBunbble 属性设置为 true。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代浏览器与IE9之前版本的兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// addEventListener调用的事件处理函数的this是事件目标</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>===e.currentTarget);  <span class="comment">// true</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.target.removeEventListner(<span class="string">'click'</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler4IE</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// IE9之前attachEvent的事件处理函数不会把event对象传进来，而是附加在window.event上</span></span><br><span class="line">    <span class="keyword">const</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="comment">// attachEvent调用的事件处理函数的this是window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>===<span class="built_in">window</span>);  <span class="comment">// true</span></span><br><span class="line">    e.returnValue = <span class="literal">false</span>;</span><br><span class="line">    e.cancelBunbble = <span class="literal">true</span>;</span><br><span class="line">    e.target.detachEvent(<span class="string">'click'</span>, handler4IE);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>(element.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element.attachEvent(<span class="string">'onclick'</span>, handler4IE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-ajax-请求以及跨域"><a class="markdownIt-Anchor" href="#12-ajax-请求以及跨域"></a> 12. Ajax 请求以及跨域</h2>
<ul>
<li>原生的 Ajax 请求代码如下:
<ol>
<li>HTTP 请求的各部分有指定顺序：请求方法和 URL 首先到达，然后是请求头，最后是请求主体。XMLHTTPRequest 实现通常虽然直到调用 send()方法才开始启动网络，但是其内部 API 的设计仍要其调用顺序上按照 open、setRequestHeader、send 的顺序。</li>
<li>readyState 属性的 0==&gt;UNSENT(open 方法尚未调用)，1==&gt;OPENED(open 方法已调用)，2==&gt;HEADERS_RECEIVED(接收到头信息)，3==&gt;LOADING(接收到响应主体)，4==&gt;DONE(响应完成)，status 和 statusText 属性分别以数字和文本的形式返回 HTTP 状态码。</li>
<li>常见的状态码：200(ok，请求成功)、301(Moved Permanently，永久移动，请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替)、302(Move temporarily，临时移动，请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求)、304(Not Modified，未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源)、400(Bad Request，客户端请求的语法错误，服务器无法理解)、403(Forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求)、404(Not Found，服务器无法根据客户端的请求找到资源)、500(Internal Server Error，服务器内部错误，无法完成请求)、503(Service Unavailable，由于超载或系统维护，服务器暂时的无法处理客户端的请求)、504(Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求)</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'https://www.fs.com/FHH/EM1HER/relationPattern/listRelationPatternsByEa?traceId=E-E.2.1000-37968006&amp;_fs_token=E3WpC3GqC3WjE31YC2qqDZDXBM9YP6KjCsOtOZLbOZTZDZLY'</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">describeApiName</span>: <span class="string">"PartnerObj"</span>, <span class="attr">is_only_active</span>: <span class="literal">true</span>&#125;));</span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP 缓存机制：<a href="https://juejin.im/post/5ab9ad5c6fb9a028c22ac671" target="_blank" rel="external">https://juejin.im/post/5ab9ad5c6fb9a028c22ac671</a></li>
</ul>
<h2 id="13-客户端存储"><a class="markdownIt-Anchor" href="#13-客户端存储"></a> 13. 客户端存储</h2>
<ul>
<li>客户端存储技术：localStorage、sessionStorage、cookie 和 IndexedDB，它们之间的区别很大，但同时也有各自的应用范围。</li>
<li>localStorage：1. 存储数据格式：浏览器仅仅支持存储字符串类型数据的存储，如果存对象数据进去会将结果保存为“[object Object]”，所以存储对象数据一般讲对象 JSON.stringify()转化成字符串再存，读取时再用 JSON.parse()转回对象；2. 存储数据 API：全局对象（挂载在 window 下），可以将其当做对象一样去读取设置，如 localStorage.name=&quot;dengxy&quot;，当然这种方式无法完成删除某个属性，或者清空操作。官方提供了 getItem、setItem、removeItem、clear 方法。3. 有效期和作用域：localStorage 存储的数据是永久性的，除非 web 应用清除或者用户通过设置浏览器删除，否则它是永不过期的，而其作用域则限定在文档源（同源策略中的源）级别，同源的文档间共享同样的一份 localStorage。但是需要注意的其作用域也受浏览器类型限制，如 Chrome 和 Firefox 之间的两个同源文档肯定不共享。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某个localStorage的属性，如果它存储的是对象JSON.stringify后的结果，请返回原对象，否则返回本身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStorageItem</span>(<span class="params">itemName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = localStorage.getItem(itemName);</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        res = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>sessionStorage: 和 localStorage 一样是全局对象，存储 API，唯一区别是其作用域和有效期：<strong>同一个窗口</strong>下的同源文档之间可以共享，所以同一个浏览器下的不同的窗口之间的同源文档是能共享 localStorage 不能共享 sessionStorage 的，而同一个窗口的不同窗体(iframe)之间的同源文档可以共享 sessionStorage。而且其有效期也是该窗口的生命周期，也即关闭了该窗口 sessionStorage 也会被删除。</li>
<li>localStorage 和 sessionStorage 在不同作用域下的通信：storage 事件，首先这个事件只能在 localStorage 或者 sessionStorage 的内容改变时才会触发，且为其他作用域（如其他的同源窗口，同源窗体，每个域下都有自己的 window，所以每个 window 的 storage 事件也是独立的）下的 localStorage 和 sessionStorage 改变会触发本作用域的 storage 事件。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListner(<span class="string">'storage'</span>, (&#123;type, newValue, oldValue, url&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'localStorage'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newValue, oldValue, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"box"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> ifm = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">ifm.name = <span class="string">"myifm"</span>;</span><br><span class="line">ifm.src = <span class="string">"/test.html"</span>;</span><br><span class="line">box.appendChild(ifm);</span><br><span class="line">frames.myifm.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> oldVal = frames.localStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line">    frames.localStorage.setItem(<span class="string">'name'</span>,<span class="string">`<span class="subst">$&#123;oldVal || <span class="string">''</span>&#125;</span>-changed`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>cookie: cookie 用于 web 浏览器存储少量数据，且这份数据会自动在 web 浏览器和 web 服务器之间传输。cookie 的默认有效期是 web 浏览器的会话期间，一旦用户关闭了浏览器，cookie 保存的数据就丢失了，但是也可通过设置 max-age 属性来延长其有效期。cookie 的作用域默认和创建它的 web 页面有关，对该 web 页面以及和该页面同目录或者子目录的其他 web 页面可见，比如，web 页面http://vedio.qq.com/catalog/index.html页面创建了一个cookie，那么该cookie对http://vedio.qq.com/catalog/order.html页面和http://vedio.qq.com/catalog/widgets/index.html页面都是可见的，但是它对http://vedio.qq.com/about.html页面不可见。cookie的作用域可以通过设置其domain和path属性来扩大其作用域，如把上述cookie的domain设置为’.qq.com’，path属性设置为’/’，则该cookie对http://xxx.qq.com/index.html都变成有效的。secure属性是一个布尔值，表示cookie的值是否允许以http形式通过网络传递。默认为false表示允许通过http传递的（https也可传递），但是若设置为true，则表示只允许通过https的才能传递它。对于cookie的操作，实际是操作document.cookie属性来完成，且由于cookie的名称/值中的字符串不允许包含分号、逗号和空白符，因此一般在存储和读取时用encodeURIComponent和decodeURIComponent方法，且document.cookie保存着所有的cookie，以“; ”（注意有个空格）分隔。单个 cookie 的大小不超过 4KB 大小是所有现代浏览器的限制。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cookie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cookieObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> cookieStr = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line">    <span class="keyword">const</span> cookieArr = cookieStr.split(<span class="string">'; '</span>);</span><br><span class="line">    cookieArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> arr = item.split(<span class="string">'='</span>);</span><br><span class="line">        cookieObj[arr[<span class="number">0</span>]] = arr[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">window</span>.cookieObj = cookieObj;</span><br><span class="line">    <span class="keyword">return</span> cookieObj;</span><br><span class="line">&#125;</span><br><span class="line">Cookie.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: Cookie,</span><br><span class="line">    getItem(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> cookieObj[name];</span><br><span class="line">    &#125;,</span><br><span class="line">    setItem(name, value) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cookieObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> cookieStr = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line">    <span class="keyword">const</span> cookieArr = cookieStr.split(<span class="string">'; '</span>);</span><br><span class="line">    cookieArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> arr = item.split(<span class="string">'='</span>);</span><br><span class="line">        cookieObj[arr[<span class="number">0</span>]] = arr[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cookieObj;</span><br><span class="line">&#125;;</span><br><span class="line">getCookie() <span class="comment">// &#123;_ga: "GA1.2.237819427.1522062937", _gid: "GA1.2.440379694.1529398243"&#125;</span></span><br><span class="line"><span class="comment">// max-age是和当前时间的绝对值，单位是秒，表示多少秒后该cookie失效</span></span><br><span class="line"><span class="comment">// domain和path必须和当前的url相匹配否则设置不成功</span></span><br><span class="line"><span class="comment">// max-age设置为0，则会删除该条cookie值，但是如果该条目有非默认的'domain', 'path', 'secure'属性则必须完整的信息才会删除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> extralprops = [<span class="string">'max-age'</span>, <span class="string">'domain'</span>, <span class="string">'path'</span>, <span class="string">'secure'</span>];</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(obj.name)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(obj.value)&#125;</span>`</span>;</span><br><span class="line">    extralprops.forEach(<span class="function"><span class="params">prop</span> =&gt;</span> &#123;</span><br><span class="line">        prop <span class="keyword">in</span> obj &amp;&amp; (str += <span class="string">`; <span class="subst">$&#123;prop&#125;</span>=<span class="subst">$&#123;obj[prop]&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    <span class="built_in">document</span>.cookie = str;</span><br><span class="line">&#125;;</span><br><span class="line">setCookie(&#123;<span class="attr">name</span>:<span class="string">'tester'</span>, <span class="attr">value</span>: <span class="string">'dengxy'</span>, <span class="attr">path</span>: <span class="string">'/LChenglong/'</span>, <span class="string">'max-age'</span>: <span class="number">10</span>, <span class="attr">secure</span>:<span class="literal">true</span>&#125;); <span class="comment">// "tester=dengxy; max-age=10; path=/LChenglong/; secure=true"</span></span><br><span class="line">getCookie() <span class="comment">// &#123;tester: "dengxy", _ga: "GA1.2.237819427.1522062937", _gid: "GA1.2.440379694.1529398243"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>IndexedDB：用于浏览器端存储大量数据。</li>
</ul>
<h2 id="14-跨域"><a class="markdownIt-Anchor" href="#14-跨域"></a> 14. 跨域</h2>
<ul>
<li>同源策略和跨域：同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。而源包含协议、域名和端口号三个部分，任何一个不同都是不同源。不能读取对方资源，具体体现在 1. Cookie、LocalStorage 和 SessionStorage 无法读取；2. DOM 无法获得；3. AJAX 请求不能发送。</li>
<li>document.domain 跨域：适应于主域名（例如 <code>news.qq.com</code> 和 <code>v.qq.com</code>）相同
<ol>
<li>同一个窗口的不同 iframe 窗体（包括_top）的 cookie 跨域：cookie 首先单条 cookie 可以设置其 domain 和 path 来扩大其作用域，可以让其和同主域名下的其他网站共享。但是如果 cookie 是服务器端传来的，其 domain 和 path 的设置已经导致 cookie 不共享，但是可以在两个窗体都设置 <code>document.domain=&quot;qq.com&quot;</code>，这样这两个窗体就可以互相读取对方的 document.cookie 的内容了。</li>
<li>iframe 窗口和 window.open 方法打开的窗口的 DOM 跨域：同上，两个窗口或窗体都设置 <code>document.domain=&quot;qq.com&quot;</code>后，就可以通过 document.getElementById(&quot;myIFrame&quot;).contentWindow.document 拿到子窗体的 document 对象，可以通过 window.parent.document 拿到父窗体的 document 对象。</li>
</ol>
</li>
<li><code>window.name</code> 跨域：<code>window.name</code> 属性的最大特点是，无论是否同源，前一个网页设置了这个属性，后一个网页可以读取它，例如前一个网页是 <code>www.test1.com</code>，我们在该网页 onload 后设置 window.name=dataStr（仅支持字符串），然后再跳转 <code>www.test2.com</code> 后，我们读取 <code>window.name</code> 仍然是 dataStr。所以可以利用这一点，可以先打开到一个代理界面（和当前网页同域）这样可以取到其 window 对象并且设置其 <code>window.name</code>，然后代理界面跳转到在目标网页（和当前网页不同域）加载完成后取到 <code>window.name</code>。</li>
<li>window.postMessage 跨域：HTML5 标准引入的专业的跨文档通信 API，MDN 的语法说明 otherWindow.postMessage(message, targetOrigin, [transfer])。再接收窗口可以注册 message 事件来接收到数据：window.addEventListener('message', foo, false);
<ol>
<li>otherWindow：其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames。</li>
<li>message：将要发送到其他 window 的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化，即可以传对象。</li>
<li>targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;（表示无限制）或者一个 URI。</li>
<li>e.data：从其他 window 中传递过来的数据。</li>
<li>e.origin：事件被发起的源，返回事件发起窗口的 location.origin。</li>
<li>e.source：事件被发起的窗口的 window 引用。</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. window.open打开的窗口之间的通信</span></span><br><span class="line"><span class="comment">// 1.1 首先在将打开的窗口www.test.com网页必须有message事件监听</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(e.origin === <span class="string">"https://www.ceshi112.com"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.data, e.source===<span class="built_in">window</span>.opener); <span class="comment">// &#123;tester: 'dengxy'&#125; true</span></span><br><span class="line">        e.source.postMessage(<span class="string">'done'</span>, e.origin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1.2 在主页面www.ceshi112.com上打开窗口并postMessage</span></span><br><span class="line"><span class="keyword">const</span> testWindow = <span class="built_in">window</span>.open(<span class="string">'https://www.test.com'</span>);</span><br><span class="line"><span class="comment">// 由于打开跨域的网址取得的window对象是无法监听onload事件的，所以无法早知道打开的网页何时渲染完成，所以做一个循环任务来监听messageEndFlag</span></span><br><span class="line"><span class="keyword">const</span> intervalTask = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// window.open打开窗口失败（网址不存在或者被浏览器拦截）时需要取消任务</span></span><br><span class="line">    <span class="keyword">if</span> (testWindow) &#123;</span><br><span class="line">        testWindow.postMessage(</span><br><span class="line">            &#123; <span class="attr">tester</span>: <span class="string">'dengxy'</span> &#125;,</span><br><span class="line">            <span class="string">'https://www.test.com'</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearInterval(intervalTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(e.origin === <span class="string">"https://www.test.com"</span> &amp;&amp; e.data === <span class="string">'done'</span>) &#123;</span><br><span class="line">        clearInterval(intervalTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. iframe之间的通信与此类似</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JSONP 跨域：适应于 Ajax 请求跨域，它的基本思想是，使用&lt;script&gt;元素进行 Ajax 传输不受同源策略的影响，因此可以从其他服务器请求数据，第二个原因是包含 JSON 编码数据的响应体会自动解码（执行）。所以必须是包裹后的 JSON 响应：handleResponse([1, 2, {}])，也提前定义好了全局函数 handleResponse。JSONP 只支持 GET 请求。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照指定url完成一个JSONP跨域请求并响应，假设传参(http://example.com/request, foo)，请求格式为'http://example.com/request?callback=foo'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackFoo</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSONP</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?callback=<span class="subst">$&#123;callback.name&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">getJSONP(<span class="string">'http://example.com/request'</span>, callbackFoo);</span><br></pre></td></tr></table></figure>
<ul>
<li>CORS（Cross-Origin Resource Sharing）：跨源资源分享，需要浏览器和服务器同时支持，支持所有类型的 HTTP 请求。</li>
</ul>
<h2 id="15-前端边缘知识"><a class="markdownIt-Anchor" href="#15-前端边缘知识"></a> 15. 前端边缘知识</h2>
<ul>
<li>
<p>Date 类以及其 useful API：</p>
<ol>
<li>创建一个 Date 类实例：new Date(), new Date(millisenconds), new Date(datestring, new Date(year, month（0-11）, day, hours, mimutes, seconds, ms)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> old = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1529571020000</span>); <span class="comment">// Thu Jun 21 2018 16:50:20 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 默认是UTC时间0点0分0秒，所以转化成时区就变成8小时</span></span><br><span class="line"><span class="keyword">const</span> older = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2016-12-12'</span>); <span class="comment">// Thu Dec 12 2016 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 前两个为必须，后面都是默认参数：日期为1，时间为0</span></span><br><span class="line"><span class="keyword">const</span> oldest = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">11</span>, <span class="number">12</span>); <span class="comment">// Mon Dec 01 2016 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Date 函数的方法：Date.now()返回从 1970-01-01 00:00:00:000 到现在的毫秒数, Date.parse(dateString)返回+new Date(dateString)也是一个时间差的毫秒数。</li>
<li>Date 对象实例的方法：g[s]et[UTC]FullYear()、g[s]et[UTC]Month(0-11 表示 1-12 月)、g[s]et[UTC]Date()、g[s]et[UTC]Day(0 表示星期日)、g[s]et[UTC]Hours(0-23 表示法)、g[s]et[UTC]Minutes()、g[s]et[UTC]Seconds()、g[s]et[UTC]Milliseconds()、g[s]etTime(毫秒差值，和 valueOf()的结果一样)、getTimezoneOffset(本地时间与 UTC 时间之间相差的分钟数，如中国是-480，因为中国是+08:00，相对于 UTC 提前了 8 小时，所以 UTC-本地时间=-480)<br>
toTimeString(转化的结果前 8 为肯定为 hh:mm:ss，这对于想实现 01:00:00 秒这样的格式很有帮助)</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写一个函数实现输出当前时间如“2018年06年25日 08:00:00”格式且模拟时间每秒进行变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showNowTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> getNowTimeStr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">const</span> year = now.getFullYear();</span><br><span class="line">        <span class="keyword">const</span> month = now.getMonth() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> day = now.getDate();</span><br><span class="line">        <span class="keyword">const</span> time = now.toTimeString().slice(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;year&#125;</span>年<span class="subst">$&#123;month &lt; <span class="number">10</span> ? <span class="string">'0'</span> + month: month&#125;</span>月<span class="subst">$&#123;day &lt; <span class="number">10</span> ? <span class="string">'0'</span> + day: day&#125;</span>日 <span class="subst">$&#123;time&#125;</span>`</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> timeBox = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'j-time-box'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timeBox.textContent = getNowTimeStr();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>throw、try、catch、finally 语句：js 运行过程中，可能出现一些错误，而且任何一个 js 的报错都会阻塞其运行然后不会往下执行。这个时候把可能出错的代码放 try{}代码块中，catch{}代码块来捕获错误做出对应的举措，如某些错误就 throw 抛出，某些错误就可以接受。finally{}代码块是代码最终一定会执行的部分，相对来说 catch{}就是只有出错才会执行的部分。</p>
<ol>
<li>throw 语句模拟的就是真正的 js 报错，所以其只会往上抛出错误（本层代码也会终止继续运行），如果外层里有 catch 语句则进入 catch 语句内运行，否则直接抛出到工作台且中断 JS 的运行（JS 是单线程所以一旦抛出一个没有 catch 的错误之后的语句都不会运行）。如果只是想工作台报错提醒，可以试试 console.err(errorInfo)，这个不会中断 JS 运行。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testThrow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"报错！"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'内部'</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'外部'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">testThrow(); <span class="comment">// 工作台抛出报错，无论“内部”或者“外部”都不会打印</span></span><br><span class="line"><span class="comment">/* --------------------------- */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    testThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);  <span class="comment">// 打印出“报错！”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>finally 语句就是在 try、catch 语句之后的一定会执行的部分，无论是否是否报错。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFinally</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">JSON</span>.parse(jsonStr);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'出错啦'</span>);</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1:finally里的无论如何都会执行'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2:try语句所在代码块同级别的出错时不会继续运行，但是没有出错时会运行'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testFinally(<span class="string">"[&#123;a:1&#125;]"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3:如果没有throw error到外层或工作台时外层仍运行，否则不执行'</span>); <span class="comment">// 仅log 1</span></span><br><span class="line"><span class="comment">/* --------------------------- */</span></span><br><span class="line">testFinally(<span class="string">"[&#123;'a':1&#125;]"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3:如果没有throw error到外层或工作台时外层仍运行，否则不执行'</span>); <span class="comment">// 仅log 1</span></span><br><span class="line"><span class="comment">/* --------------------------- */</span></span><br><span class="line">testFinally(<span class="string">'[&#123;"a":1&#125;]'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3:如果没有throw error到外层或工作台时外层仍运行，否则不执行'</span>); <span class="comment">// log 1 2 3</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>try、catch、finally 在函数中，遇到 return 语句产生的化学反应。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即使try或者catch中有返回值了，但是仍然会执行finally代码块的代码，且若里面有return语句会覆盖之前的return</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseJSON</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">finally</span>: <span class="number">123</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">parseJSON(<span class="string">'[&#123;"a":1&#125;]'</span>); <span class="comment">// &#123;finally: 123&#125;</span></span><br><span class="line">parseJSON(<span class="string">"[&#123;a:1&#125;]"</span>); <span class="comment">// &#123;finally: 123&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</div><div class="post-categories"><span><a href="/categories/JavaScript/" class="category">JavaScript</a></span></div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/基础知识/">基础知识</a></div><div class="post-nav"><a href="/2018/07/19/ES6学习笔记/" class="pre">ES6学习笔记</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODA2MS8xNDU5MQ=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-new-一个构造函数实际做了什么"><span class="toc-text"> 1. new 一个构造函数，实际做了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-那些奇奇怪怪的运算符"><span class="toc-text"> 2. 那些奇奇怪怪的运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-typeof返回什么"><span class="toc-text"> 2.1 typeof()返回什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-tostring-valueof返回什么"><span class="toc-text"> 2.2 toString()、valueOf()返回什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-boolean中哪些返回了-false"><span class="toc-text"> 2.3 Boolean()中哪些返回了 false？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-string中哪些特殊注意的"><span class="toc-text"> 2.4 String()中哪些特殊注意的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-number中哪些特殊注意的"><span class="toc-text"> 2.5 Number()中哪些特殊注意的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-string-number中一个对象有什么规律"><span class="toc-text"> 2.6 String()、Number()中一个对象有什么规律？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-全等运算符的一些规则"><span class="toc-text"> 2.7 ===全等运算符的一些规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-相等运算符的一些规则"><span class="toc-text"> 2.8 ==相等运算符的一些规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-和的返回规则-短路规则"><span class="toc-text"> 2.9 &&和||的返回规则---短路规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-变量的声明提前是什么"><span class="toc-text"> 3. 变量的“声明提前”是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-object"><span class="toc-text"> 4. Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-array"><span class="toc-text"> 5. Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-function"><span class="toc-text"> 6. Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-类和模块"><span class="toc-text"> 7. 类和模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-正则表达式"><span class="toc-text"> 8. 正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-window-对象"><span class="toc-text"> 9. Window 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-document-对象"><span class="toc-text"> 10. document 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-浏览器事件"><span class="toc-text"> 11. 浏览器事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-ajax-请求以及跨域"><span class="toc-text"> 12. Ajax 请求以及跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-客户端存储"><span class="toc-text"> 13. 客户端存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-跨域"><span class="toc-text"> 14. 跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-前端边缘知识"><span class="toc-text"> 15. 前端边缘知识</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/09/webpack4进阶学习/">webpack4进阶学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/css基础知识/">css基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/ES6学习笔记/">ES6学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/再读犀牛书：JavaScript的基础知识集锦/">再读犀牛书：JavaScript的基础知识集锦</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack4/">webpack4</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/webpack4/工具/">工具</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/webpack4/工具/工程化/">工程化</a><span class="category-list-count">1</span></li></ul></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/进阶知识/" style="font-size: 15px;">进阶知识</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/基础知识/" style="font-size: 15px;">基础知识</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/webpack4/" style="font-size: 15px;">webpack4</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">邓先雨(Dengxy).</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>