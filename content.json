[{"title":"webpack4进阶学习","date":"2018-11-09T06:39:13.000Z","path":"2018/11/09/webpack4进阶学习/","text":"1. webpack 是什么，它给前端工程化带来了哪些影响？ webpack 是一个现代 JavaScript 应用程序的静态模块打包器，它的原理也还是在本地（当然也可以在服务器端）的 Node 环境下运行一系列的脚本，通过这些脚本帮我们把源代码文件编译打包成一个工程化后的文件，还可以帮我们起一个 http server 供本地启动调试，这个过程大大减少我们开发效率，让我们专注于业务代码的实现。 2. 定制化配置 由于前端在本地开发环境和线上生产环境有许多的不同，如本地开发时需要一个 http server 提供实时的展示以及代码需要方便 debug，而线上发布时可不需要开一个 http server 且希望代码能编译的更小。webpack4 之前的做法一般是两个不同的配置文件，但是 webpack v4.0.0 开始，我们更多的只需要一个配置文件，通过区分不同的 mode，从而对配置文件有取舍的去识别和运行。 基础依赖：Node.js、webpack、webpack-cli。 12npm init -ynpm i -D webpack webpack-cli Entry：这是 webpack 非常重要的概念，可以在 webpack.config.js 文件中以 entry 属性去配置。如何理解 entry 呢？webpack 其实把文件打包的最后，是一个 html 文件，这个 html 文件里面一定会以 script 标签引入我们在 entry 中定义的 js 文件。而生成的 html 作为实际放在服务器上时被访问的第一个文件，重要程度无需言说，里面的所有内容可以通过 HtmlWebpackPlugin 来定制化的。回到 entry，其作为我们入口 js 文件，webpack 会分析其代码中的所有依赖（代码中引入的其他资源文件）来开始创建依赖图(dependency graph)，绝大部分情况下都是单文件入口来创建一个单页应用程序，在 webpack4 之前的一些做法是在 entry 中写一个 vendor 的入口，作为依赖性独立请求以达到长效缓存的目的(配合着 CommonsChunkPlugin 的使用)，但是在 webpack4 中已经废弃，具体长效缓存后面会详细讲解 123456789101112131415161718// 形式1：字符串，编译后生成默认的姓名main.[chunkhash:7].jsconst config = &#123; entry: \"./src/index.js\"&#125;;// 形式2：对象，编译后生成[customName].[chunkhash:7].jsconst config = &#123; entry: &#123; [customName]: \"./src/index.js\" &#125;&#125;;// 形式3：对象，适应于多页应用中const config = &#123; entry: &#123; pageOne: \"./src/pageOne/index.js\", pageTwo: \"./src/pageTwo/index.js\", pageThree: \"./src/pageThree/index.js\" &#125;&#125;; Output：webpack 从入口文件开始编译各类资源文件，然后需要把这些资源文件输出时，这些编译后的资源文件的配置就是通过 Output 的属性配置。filename 设置生成文件的名称，path 设置编译后的文件的路径，publicPath 设置文件的前缀路径，一般用于 cdn，但是具体的设置在 loader 中会更合适，所以暂时看来算是一个很少用也很鸡肋的属性 12345678const path = require('path')module.exports = &#123; output: &#123; path: path.resolve(__dirname, 'dist') filename: '[name].[chunkhash:7].js', &#125;,&#125; Mode：webpack4 之前可能最大的表现层面的改动就是推出 mode 模式，以几种不同的 mode 的内置默认处理来简化之前的多个配置文件。具体表现为我们现在只需要写一个配置文件 webpack.config.js，推荐的写法是根据不同的 cli 的传参 return 不同的 config 配置。当然我们也可以写多个配置文件，然后指定该配置文件的 mode，它会与该 mode 下的默认配置进行 merge，即_.extend(theModeDefaultConfig, yourConfig)。 mode 的可以取值是 none、development、production。若 config 文件中没有写配置，且外部的 cli 命令的传参也没有传 mode，则默认是 production。 mode 为&quot;node&quot;的时候也有默认配置，如下： 1234567891011121314151617181920212223module.exports = &#123; mode: \"none\", performance: &#123; hints: false &#125;, optimization: &#123; flagIncludedChunks: false, occurrenceOrder: false, sideEffects: false, usedExports: false, concatenateModules: false, splitChunks: &#123; hidePathInfo: false, minSize: 10000, maxAsyncRequests: Infinity, maxInitialRequests: Infinity &#125;, noEmitOnErrors: false, checkWasmTypes: false, minimize: false &#125;, plugins: []&#125;; mode 为&quot;development&quot;的时候配置了很多对于开发过程中的优化项和插件，如下： 1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; mode: 'development' devtool: 'eval', cache: true, performance: &#123; hints: false &#125;, output: &#123; pathinfo: true &#125;, optimization: &#123; namedModules: true, namedChunks: true, nodeEnv: 'development', flagIncludedChunks: false, occurrenceOrder: false, sideEffects: false, usedExports: false, concatenateModules: false, splitChunks: &#123; hidePathInfo: false, minSize: 10000, maxAsyncRequests: Infinity, maxInitialRequests: Infinity, &#125;, noEmitOnErrors: false, checkWasmTypes: false, minimize: false, &#125;, plugins: [ new webpack.NamedModulesPlugin(), new webpack.NamedChunksPlugin(), new webpack.DefinePlugin(&#123; \"process.env.NODE_ENV\": JSON.stringify(\"development\") &#125;), ]&#125; mode 为&quot;production&quot;的时候配置了很多对于生产环境下中的优化项和插件，如下： 123456789101112131415161718192021222324252627282930313233343536module.exports = &#123; mode: \"production\", performance: &#123; hints: \"warning\" &#125;, output: &#123; pathinfo: false &#125;, optimization: &#123; namedModules: false, namedChunks: false, nodeEnv: \"production\", flagIncludedChunks: true, occurrenceOrder: true, sideEffects: true, usedExports: true, concatenateModules: true, splitChunks: &#123; hidePathInfo: true, minSize: 30000, maxAsyncRequests: 5, maxInitialRequests: 3 &#125;, noEmitOnErrors: true, checkWasmTypes: true, minimize: true &#125;, plugins: [ new UglifyJsPlugin(/* ... */), new webpack.DefinePlugin(&#123; \"process.env.NODE_ENV\": JSON.stringify(\"production\") &#125;), new webpack.optimize.ModuleConcatenationPlugin(), new webpack.NoEmitOnErrorsPlugin() ]&#125;; 如何通过一个 webpack 文件来实现多个配置下的输出呢？答案是 webpack 命令下的 config 文件除了接受一个对象以外还可以输出一个函数来解析，所以可以在 cli 命令中传入 mode，配置文件中对于不同 mode 情况去定制化。 如下配置可以在命令中 123456789101112131415161718192021222324// package.json&#123; \"scripts\": &#123; \"start\": \"webpack-dev-server --mode=development\", \"dev\": \"webpack --mode=development\", \"build\": \"webpack --mode=production\" &#125;&#125;// webpack.config.jsconst config = &#123; entry: './app.js' // ...其他的通用配置&#125;;module.exports = (env, argv) =&gt; &#123; if (argv.mode === 'development') &#123; config.devtool = 'source-map'; // ...其他的development环境下的个性设置配置 &#125; if (argv.mode === 'production') &#123; //...其他的production环境下的个性设置配置 &#125; return config;&#125;; 总结一下可以发现 webpack4 新增了很多在 cli 命令中传参数，而传的参数优先级是高于配置文件的参数的，如&quot;start&quot;: &quot;webpack-dev-server --mode=development --port=9999&quot;，而 webpack.config.js 的 devServers 设置的 port 为 3000，本地 server 还是启动的 3000 端口。还可以看到 webpack 默认会找根目录下的 webpack.config.js 文件，其实还可以在 cli 命令下增加–config webpack.prod.js 这种定制化指定配置文件 Loaders：loader 是用来解析源代码的转换工具，如把 ts 文件转换成 js，把 es6 的语法用 babel-loader 转成 es5 可以被旧浏览器兼容处理。同一个文件被多个 loader 解析时，其形式是从右像左的解析过程，如我们解析 less 文件，应该是 less-loader 先把 less 文件转换成 css 文件，然后 css-loader 把 css 文件中的依赖性如@import 和 url()解析成实际真正的路径，如果不想生成 css 文件，可以再用 style-loader 把 css 文件写在 header 的 style 标签中以减少 http 请求。而正常的写 loader 的过程是从右到左的，use: [ 'style-loader', 'css-loader', 'less-loader' ] Plugins：插件是在 webpack 整个生命周期中都会运行的，通过插件可以定制化的修改和配置编译的过程和结果，这是与 loader 只是在 import/require 文件时才会被调用是有本质区别的。webpack 提供了丰富的 plugin，具体可以看官网每个插件的作用。 3. 配置文件示例 这是最近的一个项目的配置文件，解决了 webpack 配置过程中常见的问题： 各类 loader 的加载：babel 转义 es6，eslint 检测代码规范性，postcss-loader 的正确加载; 开发环境的本地 server 可以局域网内被访问，且显示了本机 ip 地址方便给局域网内其他用户访问; 将第三方引用的库从单独分离出 vendors 文件，这样在外部依赖库不变的情况下，只是修改业务代码 vendors 文件的 hash 后缀不会改变从而达到缓存的目的; 开发环境和构建环境分离，且区分测试环境和线上环境以构建出在不同环境下运行的代码（因为测试环境下的 api 接口肯定和线上环境是不一样的）; 应用 webpack-bundle-analyzer 插件分析代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203// webpack.config.jsconst path = require(\"path\");const webpack = require(\"webpack\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const VueLoaderPlugin = require(\"vue-loader/lib/plugin\");const config = &#123; entry: \"./src/index.js\", output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"[name].[chunkhash:7].js\" &#125;, module: &#123; rules: [ &#123; enforce: \"pre\", test: /\\.js$/, exclude: /(node_modules|bower_components)/, loader: \"eslint-loader\" &#125;, &#123; test: /\\.vue$/, loader: [\"vue-loader\", \"eslint-loader\"], exclude: /node_modules/ &#125;, &#123; test: /\\.js$/, use: [ &#123; loader: \"babel-loader\", options: &#123; /* eslint global-require: \"off\" */ plugins: [\"@babel/plugin-syntax-dynamic-import\"] &#125; &#125; ], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, use: [ \"style-loader\", &#123; loader: \"css-loader\", options: &#123; importLoaders: 1 &#125; &#125;, \"postcss-loader\" ] &#125;, &#123; test: /\\.less$/, use: [ \"style-loader\", &#123; loader: \"css-loader\", options: &#123; importLoaders: 2 &#125; &#125;, \"postcss-loader\", \"less-loader\" ], exclude: /node_modules/ &#125;, &#123; test: /\\.(png|svg|jpg|jpeg|gif|ico)$/, use: [ &#123; loader: \"url-loader\", options: &#123; limit: 8192, name: \"static/images/[name].[hash:7].[ext]\" &#125; &#125; ] &#125;, &#123; type: \"javascript/auto\", test: /\\.json$/, use: [ &#123; loader: \"file-loader\", options: &#123; limit: 8192, name: \"static/lottie/[name].[hash:7].[ext]\" &#125; &#125; ], exclude: /node_modules/ &#125; ] &#125;, resolve: &#123; extensions: [\".js\", \".vue\"], alias: &#123; \"~\": path.resolve(__dirname, \"src\") &#125; &#125;, devServer: &#123; open: false, host: \"0.0.0.0\", useLocalIp: true, stats: \"errors-only\" &#125;, plugins: [ new CleanWebpackPlugin([\"dist\"]), new HtmlWebpackPlugin(&#123; filename: \"index.html\", template: \"index.html\", inject: true &#125;), new VueLoaderPlugin() ], optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: \"vendors\", chunks: \"all\" &#125; &#125; &#125; &#125;&#125;;module.exports = (env, argv) =&gt; &#123; // 区分测试环境和线上环境 const ENV = `$&#123;argv.env.toUpperCase()&#125;_ENV`; config.plugins.push( new webpack.DefinePlugin(&#123; \"process.env.RUN_ENV\": JSON.stringify(ENV) &#125;) ); if (argv.mode === \"development\") &#123; config.devtool = \"source-map\"; &#125; if (argv.mode === \"production\") &#123; if (argv.report === \"true\") &#123; const &#123; BundleAnalyzerPlugin &#125; = require(\"webpack-bundle-analyzer\"); config.plugins.push(new BundleAnalyzerPlugin()); &#125; &#125; return config;&#125;;// package.json&#123; \"scripts\":&#123; \"serve\": \"webpack-dev-server --mode=development --env=test\", \"dev\": \"npm run serve\", \"build-test\": \"webpack --mode=production --env=test\", \"build\": \"webpack --mode=production --env=online\", \"analyz\": \"webpack --mode=production --env=online --report=true\" &#125;, \"devDependencies\": &#123; \"@babel/core\": \"^7.0.0\", \"@babel/plugin-syntax-dynamic-import\": \"^7.0.0\", \"@babel/preset-env\": \"^7.0.0\", \"autoprefixer\": \"^9.1.5\", \"babel-eslint\": \"^9.0.0\", \"babel-loader\": \"^8.0.2\", \"clean-webpack-plugin\": \"^0.1.19\", \"copy-webpack-plugin\": \"^4.5.2\", \"css-loader\": \"^1.0.0\", \"eslint\": \"^5.5.0\", \"eslint-config-airbnb-base\": \"^13.1.0\", \"eslint-loader\": \"^2.1.0\", \"eslint-plugin-import\": \"^2.14.0\", \"eslint-plugin-vue\": \"^5.0.0-beta.3\", \"file-loader\": \"^2.0.0\", \"html-webpack-plugin\": \"^3.2.0\", \"json-loader\": \"^0.5.7\", \"less\": \"^3.8.1\", \"less-loader\": \"^4.1.0\", \"postcss-loader\": \"^3.0.0\", \"postcss-px-to-viewport\": \"^0.0.3\", \"style-loader\": \"^0.23.0\", \"url-loader\": \"^1.1.1\", \"vue-loader\": \"^15.4.1\", \"vue-router\": \"^3.0.1\", \"vue-template-compiler\": \"^2.5.17\", \"webpack\": \"^4.18.0\", \"webpack-bundle-analyzer\": \"^3.0.2\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.8\" &#125;, \"dependencies\": &#123; \"axios\": \"^0.18.0\", \"lottie-web\": \"^5.4.1\", \"vant\": \"^1.3.2\", \"vue\": \"^2.5.17\", \"vue-route\": \"^1.5.1\" &#125;, \"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\" ]&#125; 仍有不足之处以后遇到再研究和补充：如果某些 vendor 不需要在首次进入的时候加载，那么把其集中打包在 vendors 里就很不合理，尤其是这样的依赖变多时，如果定制化的分离一些 vendor 让其异步被浏览器加载，这样既会减少首屏加载时间也减少了请求带宽大小","categories":[{"name":"webpack4","slug":"webpack4","permalink":"https://dengxianyu.gitee.io/categories/webpack4/"},{"name":"工具","slug":"webpack4/工具","permalink":"https://dengxianyu.gitee.io/categories/webpack4/工具/"},{"name":"工程化","slug":"webpack4/工具/工程化","permalink":"https://dengxianyu.gitee.io/categories/webpack4/工具/工程化/"}],"tags":[{"name":"进阶知识","slug":"进阶知识","permalink":"https://dengxianyu.gitee.io/tags/进阶知识/"},{"name":"webpack","slug":"webpack","permalink":"https://dengxianyu.gitee.io/tags/webpack/"},{"name":"webpack4","slug":"webpack4","permalink":"https://dengxianyu.gitee.io/tags/webpack4/"}]},{"title":"css基础知识","date":"2018-08-23T11:59:52.000Z","path":"2018/08/23/css基础知识/","text":"《css 权威指南》是一本 2007 年出版的书，距今 11 年了，但是对于前端学习过时了吗？答案可能是没有，因为本书介绍的 css2.1 及之前的一些特性其实占据了平时写 css 的绝大部分，而 css 也是 web 前端开发很重要的一部分。第二次读希望整理出一份平时工作中疑惑、遗漏的重要的知识点。 0. HTML 元素的认识 最早期没有 CSS 的时候，HTML 试图用各种元素以及元素本身的内置属性和一些属性来控制其展示形式，当然我们知道最后很失败，那些如 center 元素的都已经为历史摈弃，推出了样式和元素分离，css 由此而生。但是 css 也是在元素的基础上工作的，所以元素本身的一些固有属性还是有所依赖的。 元素的分类：这对于一些 css 的属性作用在这些不同的元素上是不同的，有的是失效的（text-align 只能影响块级元素内部的文本水平对齐方式，对于非块级元素不起作用），有的会产生不一样的效果。 块级元素：浏览器默认给其 display:block，会在其元素框前后生成分隔框以让自身可以单独占用一行，如&lt;div&gt;、 &lt;p&gt;、&lt;ul&gt;； 行内元素：浏览器默认给其 display:inline，不会对其前后的元素形成分隔框，设置其 width 和 height 属性将无效，其内容完全依赖其内文本内容支撑的，如&lt;span&gt;、&lt;a&gt;、&lt;label&gt;； 替换元素：浏览器默认给其 display:inline-block，和行内元素一样不会产生分隔框，但是其内容并非有文档内容产生，而是根据其他条件，如 img 元素内容由 src 的图片生成内容，input 元素的内容由其 type 属性决定生成不同的表单； 非替换元素：顾名思义，不是替换元素的元素。 1. css 如何作用于网页 加载 css 的三种方式:外部样式表、内部样式表、内联样式（又称行内样式）。 外部样式表： &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;sheet1.css&quot; media=&quot;all&quot; /&gt; 内部样式表：&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; 内联样式：&lt;p style=&quot;color: gray; font-size: 16px;&quot;&gt;test&lt;/p&gt; @import 指令导入外部样式表：@import url(http://qq.com/lib/css/test.css)这种绝对地址和@import url(../assets/style/test.css)相对地址都是支持的，且@import 指令可以出现在外部样式表和内部样式表，但都必须放在要先于除了@charset 的其他任何 CSS 规则，否则不生效 @import 和 link 标签引入外部样式表有什么区别? link 标签无兼容性问题，@import 是 css2.1 提出的； 不推荐以@import 引入外部样式的原因在于： a. @import 引入的外部样式文件会是网页解析完和开始其他下载之后的最后处理的下载请求，而且在同时有 link 和 style 标签中的@import 存在时会在 IE 下破坏并行下载; b. link 混合@import 会破坏并行下载，这是一个很严重的问题，这会导致原本并行下载的样式变成一个一个的同步下载。 基于上面两点，@import 很容易导致破坏并行下载，所以可能让页面加载和渲染完成时间增长，容易造成页面闪烁（样式后面生效造成的页面突变） href 和 src 的区别，以及引申出来前端的优化策略… href（Hypertext Reference 的简写）用于建立当前元素和文档之间的链接，应用有 link、a 标签。如 link 标签的加载让浏览器明白当前资源是一个样式表，页面解析不会暂停（当文件下载完成时会在下一帧渲染新的样式规则）。 src（source 的简写）是嵌入当前资源到当前文档元素定义的位置，应用有 img、script、iframe。如加载到 script 标签（在没有 defer、async 修饰属性时）会让浏览器通过 src 去下载外部样式，期间浏览器 block 住不会解析标签后的其他元素，直到下载完成并解析完成 js 文件，才会继续下一步的解析，所以我们需要把不重要的 js 的 script 标签尽量放置后面，加快首次访问加载和渲染速度。但 img 元素不会阻止到文档的解析。 2. css 选择器以及作用规则 css 的各种类型选择器众多，但是是否应用恰当真的很关键，有的时候写的好的 css 样式表对于后续的维护和修改至关重要。 通配符：_表示任意元素，单独应用不多，因为通配符对于后续整个文档结构都加了一个默认样式，和耗费性能。举例_ { margin: 0; padding: 0 } 元素名选择器：直接以元素名称来选择。举例label { color: blue; } class 选择器：需要在 class 名称前加 . 。举例.red { background-color: red; } id 选择器：需要在 id 名前加 # 。举例#main { width: 100%; } 属性选择器：以[]中写属性名来选择某一类，其分为 6 种：没有=号，表示所有拥有此属性即可的；=号表示属性值全匹配；~=表示属性值中以空格来分可以匹配到某个值；^=表示属性值以某个值开头；$=表示属性值以某个值结尾；*=表示属性值包含某个值即可。 123456789101112131415161718192021222324252627&lt;style type=\"text/css\"&gt;*[disabled] &#123; color: gray;&#125;/* =必须全匹配 */*[title=\"test css selector\"] &#123; color: blue;&#125;/* ~=必须匹配其某个单词 */*[title=\"css\"] &#123; color: blue;&#125;/* ^=匹配开头，不限是否为单词 */*[title^=\"te\"] &#123; color: blue;&#125;/* $=匹配结尾，不限是否为单词 */*[title$=\"tor\"] &#123; color: blue;&#125;/* *=匹配任意存在的 */*[title=\"ss s\"] &#123; color: blue;&#125;&lt;/style&gt;&lt;input type=\"text\" value=\"不可编辑\" disabled/&gt;&lt;p title=\"test css selector\"&gt;test css selector&lt;/p&gt; 后代选择器：以空格连接，如body p { color: blue; } 子元素选择器：以&gt;连接，如body&gt;main { width: 100% } 相邻兄弟选择器：以+连接，只能是相邻的兄弟，如li+li { font-weight: bold; }不能匹配到第一项列表 伪类：可以看做是为该元素加了一个特定的类，这个类生效是需要一些条件的。已有的伪类有：:link(未被访问的链接)、:visited(已经被访问的链接)、:hover(元素被悬浮时)、:active(用户激活该元素时，最常用在a标签被点击时)、:focus(表单元素获取到输入焦点时)、:first-child(作为其父类的第一个元素时)、:lang(某种语言匹配到时，如*lang(fr) {font-style: italic;})。伪类可以多个同时组合，如a:link:hover和a:visited:hover 伪元素：可以看做是插入到文档中的元素，已有的伪元素有：:first-letter(设置某个块级元素首字母的样式)、first-line(设置某个块级元素首行的样式)、before(设置某个元素前面的内容)、after(设置某个元素后面的内容)。伪元素必须放在选择器的最后面，如写成p:first-line em就是不合法的。 特殊性：多个样式规则同时作用于同一个元素时，元素选择了哪个规则就是根据不同的样式规则有不同的特殊性，有最高特殊性的股则会胜出。 内联样式的特殊性为 1,0,0,0，id 选择器的特殊性为 0,1,0,0，class 选择器、属性选择器和伪类的特殊性为 0,0,1,0，元素选择器和伪元素选择器为 0,0,0,1，结合符和通配符对特殊性没有贡献。一个选择器最终的特殊性是每个选择器特殊性之和。 !important：只能出现在样式规则的最后面，前面有无空格都可以，一般有空格更为标准。它表征该条样式规则会有单独的分组，大于其他任何没有!important 的声明，但是如果也存在其他！important 的声明作用，则二者再按照特殊性规则比较。 浏览器规则和继承：浏览器有一些自己的规则，如把 a 链接都渲染成蓝色；同样 css 的 color、一些字体属性、还有一些文本属性都是默认继承父元素的。实际上，通配符&gt;浏览器规则&gt;继承 特殊性在比较的时候，遵循一个规则：不存在进位。即假如出现 11 个类选择器，那么其特殊性为 0,0,11,0，不会超过一个一个 id 选择器 0,1,0,0。且存在相同的特殊性时，会遵循每个规则的先后顺序，后续的规则会覆盖前面的规则。 3. 字体属性和文本属性 em 和 px：px 是绝对单位，而 em 是相对单位，会相对当前元素的 font-size 的值而计算出来。如某元素 font-size 是 16px，设置其 padding 为 1.5em，则实际上其 padding 为 24px。 font-family: 可以用逗号分隔指定多个字体的值，前面的字体若浏览器不支持则从会依次找后面的字体，直到最后一个字体。当字体名称中包含空格、#、$这些特殊字符时需要用引号（一般用单引号）引入。p { font-family: Times, 'New York', serif; } font-weight: 初始值是 normal，还可以取 bold、light、bolder、lighter、inherit、100-900。normal、light 和 bold 都是绝对值，而 bolder、lighter 是相对于其父元素 font-weight 的相对值，在其值上 ±200。但是最终浏览器显示情况又和字体息息相关，若该字体本身没有粗体或细体，则所有的粗体或细体仍和正常字体一样。 font-size: 若其设置值单位为 em，则是相对其父元素的 font-size，和百分数等价。如设置某元素 font-size 为 1.5em，其父元素 font-size 为 14px，则其 font-size 为 21px，等价于设置值为 150%。若此时设置该元素的 line-height 为 1em，也是 21px 而非 14px。 font-style: 可以取值 italic/oblique/normal/inherit。italic 表示斜体，oblique 表示倾斜的，其实有的字体下二者一样的。 font-variant: 可以取值 small-caps/normal/inherit。small-caps 表示小型大写字母，会将 test 变成 TEST，但是 TEST 所占的都是小写字母所占的体积，可以自己去试一下。 font: 它是一个合并属性，[&lt;font-style&gt;][&lt;font-variant&gt;] [&lt;font-weight&gt;] &lt;font-size&gt;[/&lt;line-height&gt;] &lt;font-famliy&gt;，可以看出前三个可以采用任意的顺序也可以省略，但是后面两个值 font-size 和 font-family 是必须要的，当然 line-height 也是可选的。特别注意的所有的省略项目都是 normal，这和只定义 font-size 和 font-family 时其他项默认是继承父元素的值有区别。也就是说font: 16px sans-serif; 等价于 font: normal normal normal 16px/normal sans-serif; text-indent: 只能用于 display 设置为 block 和 inline-block 的元素，用于设置其内文本的首行缩进值。 text-align: 只能用于 display 设置为 block 和 inline-block 的元素，用于设置其内文本的水平排版方式。 line-height: 指文本行基线之间的距离，可以应用到所有元素，但是对于替换元素不生效(但是由于vertical-align的百分数是相对于line-height的值，所以还是有作用的)。文本行中的每个元素会生成一个内容区，内容区会生成一个行内框(inline-box)，行内框有四条线，如最初学习英文时的英文本的四条线，分别叫顶/中/基/底 线（top/middle/base/bottom line），默认情况下字体都是以基线为标准对齐的，底线会有 g、j 这些字母触及。line-height 控制着多行之间的垂直间隔，指出每一行的实际距离。如设置 font-size 为 16px，则底线与顶线之间的距离是 16px，但是浏览器一般会有个默认的 line-height 值为 normal，具体多少和浏览器有关系，如 Chrome 为 21px，这表示 inline-box 上下边距为 2.5px。它作用于块级元素和行内元素时是不一样的。对于行内元素，由于本身内容就是由里面的文本内容撑开的，所以若逐渐设置的 line-height 开始大于浏览器设置的 normal 的值时，才会起到效果。但是对于块级元素(inline-block)同理，设置为非负数都会有效果，设置为 0 会让每一行的字得到重叠。line-height 可以设置纯数字，如 2，表示双倍行距，和 2em 的计算值一样，但是区别在于遗传给子元素时，2 会自动遗传给子元素而 2em 会以其计算值遗传。 vertical-align: 只能用于 display 设置为 block 和 inline-block 的元素，用于设置一个元素在垂直方向其基线 baseline 与父元素的哪个线垂直，如其默认值为 baseline，表示与父元素的 baseline 垂直。若该元素没有基线，如 img 或者 input 元素，则是该元素的底端和其父元素的 baseline 垂直。其可以取值 baseline/sub/super/top/text-top/middle/bottom/text-bottom/&lt;length&gt;。没有继承性！ word-spacing/letter-spacing: 应用所有元素，单词之间的间隔/字母之间的间隔，可以应用于所有元素。默认值为 normal，相当于长度单位 0。 text-transform: 设置文本大小写的一些方式，应用所有元素，可取值 uppercase/lowercase/capitalize(每个单词首字母大写)/none(初始值，不作任何处理)/inherit， text-decoration: none/underline/overline/line-through/blink，没有继承性，所以子元素的 white-space: 应用于所有元素，控制文本中的空白符和换行符。 值 空白符 换行符 自动换行 normal 合并 忽略 允许 nowrap 合并 忽略 不允许 pre 保留 保留 不允许 pre-wrap 保留 保留 允许 pre-line 合并 保留 允许 4. 元素的排版 块级元素：块级元素的盒模型，内容区+padding+border+margin才是其在浏览器真正占据的区域。 块级元素默认情况下如果没有任何内容(空div，或者空div中嵌套中空div)则其width、height、padding、border、margin全是0，在浏览器不占据任何空间。但是一旦其有内容，则其默认width为其父元素的width，其余属性为0，height也是子元素充斥的height。 水平方向：margin-left、margin-right、width是可以设置为auto，但当某个值设置为auto就意味着该值会自动适应来让整个水平方向的占据宽度outerWidth为其父元素的width。如&lt;div style=&quot;width: 400px;&quot;&gt;&lt;div style=&quot;width: 100px; margin: auto 0 100px 0;&quot;&gt;this is a test&lt;/div&gt;&lt;/div&gt;，这个时候浏览器会自动将其margin-left替换成200px。若所有值设置都是非auto，但是其值算下来不等于父元素的width，则此时浏览器会强制将margin-right设置为auto以适应。 块级元素水平居中：若width设置为固定值，margin为auto，则这两个会保持相等值，这样就很自然实现了块级元素的水平居中效果。若width宽度值不固定，即由内容决定的子元素宽度，则可以通过将父元素设置.parent { display: inline-block; text-align: center; }来实现。 垂直方向：垂直方向设置auto并不会实现垂直居中，而是会设置为0，且垂直方向若子元素高度大于了父元素，其效果和父元素的overflow有关。 合并外边距：垂直方向的外边距会造成相邻外边距的合并，这不仅仅发生在相邻元素之间的margin-top与margin-bottom，还发生于父元素在没有设置边框和内边距属性（或者设置为0）时，使得父元素的margin-bottom直接和父元素的最后一个元素的margin-bottom接触时二者的合并。 行内元素：行内元素远比我们想象的复杂，因为它们首先是以行为单位去显示的，以里面的文本或其他内容来作为内容，而不是像块级元素生成矩形框体占据一定空间。行内元素的每一行都根据其内容确定行框，而行框由里面的每个内容的行内框确定（所有行内框的最高点和最低点确定最后的行框）。 非替换元素：非替换元素的行内框不受其margin、padding影响，只和其font-size和line-height有关。但是还是会影响其布局，尤其是当设置背景颜色的时候。 替换元素：替换元素的行内框和其margin、padding、width、height都有关系，根据其盒模型占据的位置来确定其行内框 inline-block：和替换元素一样。 IE盒模型：ie6的盒模型是width、height分别表示其内容区、padding区、border区三个部分的值，但是标准盒模型width、height仅仅表示内容区的宽高。 margin、padding：设置为百分数时是相对当前元素的父元素的width的百分比，和height没有关系，和当前元素的其他值没有关系。 color: 元素的前景色，是有继承性的。 background：元素的背景设置，不带继承性的。是以下分开属性的合起来写的值，每个值都可以省略，省略后就是默认值，可以采取任何顺序。 background-color: 元素的背景色默认值是transparent，所以当元素没有背景色时会显示到其父元素的背景色或者依次往上层级显示。 background-image: 背景图片默认值是none，也可以指定一个uri，如background-image: url(bg23.gif);，默认从元素的padding区域+content区域所组成的矩形的左上角开始放置，不会和border有所冲突。 background-repeat: 背景元素的重复性设置，默认是repeat，表示会依次重复，还可以设置的值有repeat-x、repeat-y和no-repeat。 background-position: 背景元素的定位属性，可以设置百分数，像素值，关键字（top、left、right、bottom）。注意，定位是相对元素的区域去定位的，而非图片，但是比较有意思的是如果设置50%时，会将图像中心和元素中心对齐。著名的css-spirits就是利用这个属性来实现小图合并后，在有限的区域里定位到对应的背景，如果目标图片在雪碧图的定位坐标是(100,200)，则应该设置background-position: -100px -100px;。 background-attachment: 设置元素的背景随着元素定位还是随着文档滚动，默认是前者，值为scroll，还可以设置为fixed。 浮动定位：浮动定位本身的行为复杂性很高，真的不推荐使用。。。 定位：position属性可以设置为static（默认值）、relative（相对定位，其位置正常情况下和之前保持一样，left、top的值均为相对之前位置的偏移量）、absolute（绝对定位，元素框会从文档流删除，其相对定位元素为其往上找祖先元素中第一个position不是static的元素），fixed（固定定位，元素框也会从文档删除，其相对定位为视窗本身，这和相对body是有区别的，因为前者在滚动的时候也会出现在视窗，后者可能不会）。 对于没有相对定位元素，没有设置width和height时，其大小默认是其内容，这个和正常定位的元素一样，但是若设置了top、right、bottom、left的值之后则会相应的形成一个大小，这个大小才是其真正的大小，且都是相对于其定位元素的内边距。若本身设置了width、height，则在同时有top、bottom的情况下忽略bottom、同理忽略right。 absolute定位的元素，不设置任何值时，默认定位位置是其原本在文档流的位置，只是由于脱离正常文档流，所以其下面的元素会占用它之前的位置而被其遮挡。 min/max-width/height: 可以用width和height的元素，即替换元素和所有块级元素。 visibility: 控制元素的可见性，注意其不会造成元素和文档流里删除，且该属性有遗传性，所以才会造成设置元素visibility为hidden之后，其后代元素也会消失不见。依次，可以单独设置其某个后代元素的visibility为visible，则该后代元素则会显示出来。 z-index: 只能应用于定位元素，用于改变元素相互覆盖的顺序，一般的，若没有设置为auto，会和其相对定位的元素保持一致，值越大的会显示在上层，若相同的层级则以其出现的顺序，后面的会覆盖前面的元素。 5. 表布局和列表布局以及一些需要掌握的属性 table表是一个复杂且跳不过去的东西，自己写一个table表总会感觉需要考虑太多… border-collapse: 初始值为separate，是分隔框模型，此时每个td之间会有一个间隙受border-spacing控制，一般我们还是希望另一个值collapse，即没有分隔的。 table-layout: 可以设置auto（自动布局）和fixed（固定布局），二者的差别是fixed会让浏览器渲染更快，因为它确定列表的每列宽度是由表的第一行定义，后面的单元格指定的都会被忽略。 list-style: 是三个属性list-style-type、list-style-image、list-style-position的合写，用于列表的一些设置 outline: 是outline-style、outline-width、outline-color三个属性的合写。和border不同的是它不会触发布局的改变，因为它只是显示在那，遮挡其他元素都可以而不是触发元素在布局中的位置。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://dengxianyu.gitee.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://dengxianyu.gitee.io/tags/CSS/"},{"name":"基础知识","slug":"基础知识","permalink":"https://dengxianyu.gitee.io/tags/基础知识/"}]},{"title":"ES6学习笔记","date":"2018-07-19T07:52:53.000Z","path":"2018/07/19/ES6学习笔记/","text":"0. 前言 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，本文是我再读阮一峰老师的ECMAScript 6 入门的读书笔记，中间有很多自己的总结和代码案例。 1. 变量的声明和作用域 ES6 新增 let 命令、const 命令和{}代码块内为块级作用域的概念。 const 与 let 的区别：定义的变量，如果是基本类型则不可以再被赋值，如果是引用类型是可以增删属性方法的，但是重新赋值。const 命令是不允许声明时不赋值的。 let 命令、const 命令与 var 命令定义变量的区别 定义的变量是块级作用域，var 定义的变量是函数作用域； 定义的变量不可重复定义； 定义的变量没有变量提升； 定义的全局变量不再是顶层对象的属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 1. 定义的变量是块级作用域，var定义的变量是函数作用域&#123; const a = 10; var b = 1;&#125;a; // ReferenceError: a is not defined.b; // 1// 2. 定义的变量不可重复定义const a = &#123;&#125;;var b = 2;var a = 1; // SyntaxError: Identifier 'a' has already been declaredvar b = 1; // b现在是1// 3. 定义的变量没有变量提升(function() &#123; console.log(a); // undefined var a = 12; console.log(b); // ReferenceError: b is not defined const b = 12;&#125;)();// 4. 定义的全局变量不再是顶层对象的属性var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined// 5. let、const在for循环中的应用// for循环设置循环变量的那部分(即括号内)是一个父作用域，而循环体内部是//一个单独的子作用域，怎么理解呢？就是（）内和for循环的外界是相当于&#123;&#125;分//开的，而循环体内部是在外部的&#123;&#125;代码块中的&#123;&#125;代码块，如下goto模拟&#123; var i = 0; repeat: if (i &lt; 10) &#123; // ... i++; goto repeat; &#125;&#125;// 所以如下，若在for循环中用let，则外界就获取不到outer，// 而for循环内部可以获取到outer但是也可以重新定义该变量for (let outer = 0; outer &lt; 1; outer++) &#123; const outer = 'inner outer'; console.log(outer); // inner outer&#125;console.log(outer); // ReferenceError: outer is not defined// var定义的i在外界可以获取到，所以函数执行时是10var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10// let定义的i在外界可以获取到，所以函数执行时是取函数定义时var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 2. 解构赋值与扩展运算符 解构赋值：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构，而解构可以极大的简化多个变量的赋值操作。解构赋值允许指定默认值，只有当解构的成员严格等于（===）undefined，默认值才会生效。 12345678910111213141516171819202122232425// 数组的解构赋值严格按照次序const [a, b, c] = [1, 2, 3];const [foo, [[bar], baz]] = [1, [[2], 3]];const [foo = true] = [];foo; // trueconst [x = 1] = [undefined];x; // 1const [y = 1] = [null];y; // null// 对象的解构赋值和次数无关const &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"const obj = &#123; first: \"hello\", last: \"world\" &#125;;const &#123; first: f, last: l &#125; = obj;f; // 'hello'l; // 'world'// 注意对象的简写const &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo; // \"aaa\"bar; // \"bbb\"const &#123; x: y = 3 &#125; = &#123; x: 5 &#125;;y; // 5// 对已经声明的变量用于对象解构赋值，需要加括号，不然或被解析前面的&#123;&#125;会被解析成代码块而报语法错误let x;(&#123; x &#125; = &#123; x: 1 &#125;); 扩展运算符：是三个点（…）表示，将一个任何带有 Iterator 接口的数据转为用逗号分隔的参数序列。它可以结合函数的参数和解构赋值可以很方便实现一些功能。如 ES5 中，一些函数支持传多个参数，但是若我们想传数组进入怎么办呢？通常是拿 function.apply(null, args)，现在可以直接用 function(…args)了。 123456789101112131415// 单独在console使用其实是会报错的，因为它返回的是几个逗号的连接值...[1, 2, 3]; // Unexpected number// 最常用的作为函数的参数使用console.log(...[1, 2, 3]); // 1 2 3// 可以把[]也看做一个运算符，里面即为其参数[...[1, 2, 3]]; // [1, 2, 3]// ES5中apply用扩展运算符来实现Math.max.apply(null, [14, 3, 77]) === Math.max(...[14, 3, 77]);// 解构赋值时，会自动将变量赋值为数组，但是只能放在参数的最后一位，否则会报错const [first, ...rest] = [1, 2, 3, 4, 5];rest; // [2, 3, 4, 5]const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错// 把实现了Iterator接口的数据转换成真正的数组，所以也可以转换[...'hello']; // [ \"h\", \"e\", \"l\", \"l\", \"o\" ][...document.querySelectorAll('div')]; 3. Symbol：新的数据类型 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型。 是一种原始数据类型，所以 typeof 调用实例返回&quot;symbol&quot;，且是一种类似于字符串的非引用类型而非对象这种引用类型数据。 生成一个 Symbol 实例有两种方法，一种直接是 Symbol()，一种是 Symbol.for()，后者生成的会被登记在全局环境（可以在不同的 iframe 或 service worker 中取到同一个值）中供搜索，前者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。一般的接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。Symbol.keyFor()方法只会返回 Symbol.for()产生的 Symbol 实例的 key。 123456Symbol(\"foo\"); // Symbol(foo)Symbol(\"bar\"); // Symbol(bar)Symbol(\"foo\") === Symbol(\"foo\"); // falseSymbol.for(\"test\") === Symbol.for(\"test\"); // trueSymbol.keyFor(Symbol(\"foo\")); // undefinedSymbol.keyFor(Symbol.for(\"foo\")); // \"foo\" Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。这一点上和 String 和 Number 是有区别的。 12new String(\"test\"); // String &#123;\"sss\"&#125;new Symbol(\"test\"); // TypeError: Symbol is not a constructor ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法，目的就是将语言更加规范化，如 instanceof 操作符会调用函数的[Symbol.hasInstance]方法、string 中 match、search、replace、split 这几个用到正则的都定义到了正则对象相应的方法。对象的 Symbol.iterator 属性，指向该对象的默认遍历器方法。 4. Set 与 Map 类 set 类用于生成一个可以遍历的但是其值都不重复(与===的唯一区别是 NaN 的判断)的数据结构的对象，如果把它和普通对象相比，其 key 值和 value 值是一样的，同时是可遍历的。如果和数组相比，添加相同的值会被忽略。 Set 实例的生成方法只能通过 new Set，所以 Set 是一个标准的构造函数且不可作为普通函数使用。它可以传任何具有 iterable 接口的其他数据结构，用来初始化。 1234567Array(1); // [empty]new Array(1); // [empty]Set([1, 2]); // TypeError: Constructor Set requires 'new'new Set([1, 2]); // Set(2) &#123;1, 2&#125;// 去除数组的重复成员[...new Set([1, 2, 3, 1])]; // [1, 2, 3]Array.from(new Set([1, 2, 3, 1])); // [1, 2, 3] Set 类的实例有 size 属性，返回成员的个数，add、delete、has、clear 方法。同时有四个遍历方法，可以用于遍历成员：keys()、values()、entries()返回的都是遍历器对象，forEach()使用回调函数遍历每个成员。Set 类由于键名和键值是同一个值，所以 keys()、values()返回时相同的。 123456789101112131415161718192021222324252627282930313233343536373839404142let set = new Set();set.add(&#123;&#125;);set.size; // 1set.add(&#123;&#125;);set.size; // 2s.add(1) .add(2) .add(2);s.size; // 4s.has(1); // trues.has(2); // trues.has(3); // falses.delete(2);s.has(2); // falselet set = new Set([\"red\", \"green\", \"blue\"]);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"]Set.prototype[Symbol.iterator] === Set.prototype.values; // trueSet.prototype.keys === Set.prototype.values; // truenew Set([1, 4, 9]).forEach((value, key) =&gt; console.log(key + \" : \" + value));// 1 : 1// 4 : 4// 9 : 9 Map 类型和普通对象的区别在于，但是“键”（key）的范围不限于字符串，各种类型的值（包括对象）都可以当作键，其也有 size 属性 has、clear 方法以及 keys()、values()、entries()遍历器生成函数和 forEach()遍历方法，和 Set 不同的是对键值的读写是通过 get、set 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const m = new Map();const objKey = &#123; key: true &#125;;const objVal = &#123; value: true &#125;;m.set(\"edition\", 6); // 键是字符串m.set(262, \"standard\"); // 键是数值m.set(undefined, \"nah\"); // 键是 undefinedm.set(objKey, objVal); // 键是 对象m.size; // 4m.get(objKey) === objVal; // truem.delete(); // true, 默认无参数就相当于传入undefinedm.has(undefined); // falsem.delete(null); // falsem.clear(), m.size; // 0const map = new Map([[\"F\", \"no\"], [\"T\", \"yes\"]]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"Map.prototype[Symbol.iterator] === Map.prototype.entries; // trueMap.prototype[Symbol.iterator] === Map.prototype.values; // false WeakSet 和 WeakMap 类都是不具备 iterator 接口的类，且和 Set 和 Map 的区别在于创建的实例都是弱引用，随时可能消失。这种弱引用的应用之处就是用于一些是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 5. Iterator 和 for…of 循环 遍历器接口：为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成 for…of 循环遍历操作。Iterator 的遍历过程是这样的： （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。 所以一个对象如果要具备可被 for…of 循环调用的 Iterator 接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法（即后续讲到的 Generate 函数）。 12345678910111213141516171819202122232425class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123; done: false, value: value &#125;; &#125; return &#123; done: true, value: undefined &#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125; 原生就具备 Iterator 接口的数据结构有：Array、String、Map、Set、函数的 arguments 对象、NodeList 对象、TypedArray。 调用 Iterator 接口的场合除了前面已经说过的解构赋值、扩展运算符还有一些构造函数（如 Array.from()、Map(), Set()）的传参以外，还有 yield*，它后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 123456789101112let generator = function*() &#123; yield 1; yield* [2, 3, 4]; yield 5;&#125;;var iterator = generator();iterator.next(); // &#123; value: 1, done: false &#125;iterator.next(); // &#123; value: 2, done: false &#125;iterator.next(); // &#123; value: 3, done: false &#125;iterator.next(); // &#123; value: 4, done: false &#125;iterator.next(); // &#123; value: 5, done: false &#125;iterator.next(); // &#123; value: undefined, done: true &#125; for…of 循环相比于 forEach 方法，它可以与 break 和 continue 配合使用，且比纯粹的 for 循环简单。 1234567891011121314for (var value of [1, 2, 4, 8]) &#123; if (value &lt; 8) continue; console.log(value); // 8&#125;for (var value of [1, 2, 4, 8]) &#123; if (value &gt; 6) break; console.log(value); // 1 2 4&#125;// 模拟for循环需要循环次数的问题let i = 0;for (let value of [1, 2, 3]) &#123; i++; console.log(value * i);&#125; 6. Promise 对象 js 回调地狱：由于一些不合理的写法，在回调函数中嵌套回调函数，所以函数体写的十分臃肿，大括号层层塌陷进去被戏称为回调地狱。而解决回调地狱的一种方式是将回调函数定义写在外层，直接把函数名传到回调的地方。现在 ES6 提供了 Promise 也是一种解决异步回调地狱的方式。 Promise 是异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise 对象有以下两个特点： 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 1234567891011121314// 这和事件的异步完全不同，Promise的状态可以在凝固后仍拿得到！const test = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"data\"); &#125;, 1000);&#125;).then(() =&gt; &#123; console.log(\"Promise对象已经改变为fulfilled\"); return \"test\";&#125;);setTimeout(() =&gt; &#123; test.then(data =&gt; void console.log(\"test\"));&#125;, 1500);// Promise对象已经改变为fulfilled// test Promise 是一个构造函数，用来生成 Promise 实例。构造函数接受一个函数作为参数，该函数的两个参数分别是由 JavaScript 引擎提供的 resolve 和 reject，resolve 和 reject 分别用于改变 promise 实例的状态，且仅能在这个函数中调用 resolve 或者 reject 修改，且一旦改变了就不会再变（如上所述）。生成的 promise 实例可以调用 then 方法和 catch 方法分别监听 promise 实例的状态改变后的回调函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 原生Ajax用promise封装new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (xhr.status === 200) &#123; resolve(JSON.parse(xhr.responseText)); &#125; else &#123; reject(JSON.parse(xhr.responseText)); &#125; &#125;; xhr.open(\"post\", \"url\"); xhr.setRequestHeader(\"Content-Type\", \"application/json\"); xhr.send(JSON.stringify(&#123; test: \"test\" &#125;));&#125;) .then(result =&gt; &#123; document.getElementById(\"test\").textContent = result; &#125;) .catch(error =&gt; &#123; errorTip &amp;&amp; errorTip(error); &#125;);/* new Promise()参数中的函数体会立即执行，异步执行的是外部的then/catch回调， * 且Promise实例的then/catch回调是在本轮“事件循环”结束时执行， * setTimeout(fn, 0)在下一轮“事件循环”开始时执行 */setTimeout(() =&gt; &#123; console.log(\"four\");&#125;, 0);new Promise(resolve =&gt; &#123; console.log(\"one\"); resolve();&#125;).then(() =&gt; &#123; console.log(\"three\");&#125;);console.log(\"two\");/* Promise实例的状态一旦改变就不会再次被修改， * 且一般改变状态后不应该再写语句。但是实际上写也会执行*/new Promise((resolve, reject) =&gt; &#123; resolve(\"success\"); console.log(\"shouldn't have\"); reject(new Error(\"error\"));&#125;) .then(data =&gt; &#123; console.log(data); &#125;) .catch(error =&gt; &#123; console.log(error); &#125;);// shouldn't have// success/* * throw new Error(\"error\")等价于reject(new Error(\"error\")) * 会被catch或者then的第二个函数捕获到*/new Promise((resolve, reject) =&gt; &#123; reject(new Error(\"error\"));&#125;).catch(error =&gt; &#123; console.log(error);&#125;);// Error: errornew Promise((resolve, reject) =&gt; &#123; throw new Error(\"error\");&#125;).then(null, error =&gt; &#123; console.log(error);&#125;);// Error: error resolve 或者 reject 的参数可以是一个 Promise 对象，这个时候只有当作参数的这个 Promise 对象状态变成 fulfilled 或者 rejected 时才会改变当前的 Promise 对象的状态。 1234567891011121314const start = +new Date();const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(new Error(\"fail\")), 3000);&#125;);const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(p1), 1000);&#125;);p2.then(result =&gt; void console.log(result)).catch(error =&gt; &#123; const end = +new Date(); console.log(`过了$&#123;(end - start) / 1000&#125;s`); console.log(error);&#125;);// 过了3.001s// Error: fail Promise.prototype.then：then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例），这个新的 Promise 的状态和 then 方法的返回值有关。可以采用链式写法，即 then 方法后面再调用另一个 then 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// then函数返回普通字符串，则会把结果当下一个then的参数，没有return就相当于undefined传入new Promise(resolve =&gt; &#123; resolve(\"first\");&#125;) .then(res =&gt; &#123; return res; &#125;) .then(res =&gt; &#123; console.log(res); // first &#125;);// then函数返回Promise对象，则等该promise转换状态之后再执行后面的then，相当于该promise对象的then、catchnew Promise(resolve =&gt; &#123; resolve(\"first\");&#125;) .then(res =&gt; &#123; return new Promise(resolve =&gt; &#123; resolve(\"second\"); &#125;); &#125;) .then(res =&gt; &#123; console.log(res); // second &#125;);new Promise(resolve =&gt; &#123; resolve(\"first\");&#125;) .then(res =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; reject(\"error\"); &#125;); &#125;) .then(res =&gt; &#123; console.log(res); &#125;) .catch(error =&gt; &#123; console.log(error); // error &#125;);// 总结实现多个异步操作 顺序 执行的const test1 = () =&gt; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"test1 run\"); resolve(); &#125;, 1000); &#125;);const test2 = () =&gt; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"test2 run\"); resolve(); &#125;, 1000); &#125;);const test3 = () =&gt; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"test3 run\"); resolve(); &#125;, 1000); &#125;);test1() .then(() =&gt; &#123; return test2(); &#125;) .then(() =&gt; &#123; return test3(); &#125;);function runByOrder(promises = []) &#123; if (!Array.isArray(promises)) return; if (!promises.every(p =&gt; typeof p === \"function\")) return; promises.reduce((pre, cur, curenetIndex) =&gt; &#123; const promise = curenetIndex === 1 ? pre() : pre; return promise.then(() =&gt; &#123; return cur(); &#125;); &#125;);&#125; Promise.prototype.catch：catch 方法或捕获 promise 的 reject 或者运行中抛出的错误（throw Error）。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，错误也只会被处理一次。catch 方法和 then 一样返回的是一个新的 promise 对象。 1234567891011121314151617181920212223242526272829303132333435363738new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(\"error\"); &#125;, 1000);&#125;) .then(() =&gt; &#123;&#125;) .then( () =&gt; &#123;&#125;, error =&gt; &#123; console.log(error); // error &#125; );// 和上面的等价new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(\"error\"); &#125;, 1000);&#125;) .then(() =&gt; &#123;&#125;) .catch(error =&gt; &#123; console.log(error); // error &#125;);new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(\"error\"); &#125;, 1000);&#125;) .then(() =&gt; &#123;&#125;) .then( () =&gt; &#123;&#125;, error =&gt; &#123; console.log(error); // error &#125; ) .catch(error =&gt; &#123; console.log(error); // 不会打印，因为只会捕获一次 &#125;); then 和 catch 返回的新的 promise 的状态是什么由什么决定呢？因为 then 和 reject 的参数是一个函数，其参数是上层 promise 的状态值，then 监听上一个的 return 值，catch 监听能够传播（Promise 对象的错误具有“冒泡”性质）到它这的 throw new Error(error)或者 reject(error)的 error。所以无论 then 或者 catch 函数中只要不 throw error 出来，则返回了一个新的 promise 对象状态为 fulfilled，否则状态为 rejected！ 1234567891011121314151617181920212223242526272829new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"data\"); &#125;, 1000);&#125;) .then(data =&gt; &#123; // 第一个then什么操作都不做，生成新的promise状态为fulfilled，传递数据为undefined &#125;) .then( data =&gt; &#123; console.log(data); // undefined // 第二个then里throw error，生成新的promise状态为rejected，传递数据为\"error\" throw new Error(\"error\"); &#125;, error =&gt; &#123; // 不会走到这里 &#125; ) .then( data =&gt; &#123; // 不会走到这里 &#125;, error =&gt; &#123; console.log(error); // error &#125; ) .catch(error =&gt; &#123; // 不会走到这里，因为上一个then没有throw Error出来 &#125;); Promise.all()：接受一个数组作为参数，数组里预期每一个都是 Promise 实例，若不是会用 Promise.resolve 方法转化一下。这多个 Promise 实例（例如 p1、p2、p3），包装成一个新的 Promise 实例（例如 p），p 的状态由 p1、p2、p3 决定，分成两种情况： 只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。 Promise.race()：同 Promise.all 的参数处理一样，不同的是竞速模式，会返回最快状态凝固的那个产生的新的 promise。 Promise.resolve()、Promise.reject()方法分别用于直接生成一个新的 Promise 状态已经改变的实例。 7. Generator 函数 前面已经讲到了 Generator 函数是产生遍历器对象的函数，为一些对象提供遍历器接口的。如下展示了原生的 String 部署了变量对象，其 String.prototype[Symbol.iterator]就是一个 Generator 函数。Generator 函数和普通函数的区别就是产生的结果是一个 iterator 对象，其 next 方法会每次返回一个{value:xxx, done: true/false}的对象。 12345678String.prototype[Symbol.iterator] instanceof Function; // trueconst str = \"abc\";const i = str[Symbol.iterator]();i.next(); // &#123;value: 'a', done: false&#125;i.next(); // &#123;value: 'b', done: false&#125;i.next(); // &#123;value: 'c', done: false&#125;i.next(); // &#123;value: undefined, done: true&#125;i.next(); // &#123;value: undefined, done: true&#125; Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。它有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）。返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 表达式就是暂停标志。遍历器对象的 next 方法的运行逻辑如下： 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。 12345678910111213141516171819202122// 为普通对象设置其遍历器接口var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function*() &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable]; // [1, 2, 3]// next()方法支持传参作为“上次”yield的返回值function* dataConsumer() &#123; console.log(\"Started\"); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return \"result\";&#125;const genObj = dataConsumer();genObj.next(); // 返回值为&#123;value: undefined, done: false&#125;// StartedgenObj.next(\"a\"); // 返回值为&#123;value: undefined, done: false&#125;// 1. agenObj.next(\"b\"); // 返回值为&#123;value: 'result', done: false&#125;// 2. b yield* 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。 123456789101112131415161718192021222324252627282930313233function* foo() &#123; yield \"a\"; yield \"b\";&#125;function* bar() &#123; yield \"x\"; yield* foo(); // yield \"y\";&#125;// 等同于function* bar() &#123; yield \"x\"; for (let v of foo()) &#123; yield v; &#125; yield \"y\";&#125;// 将数组的展平输出function* flat(a) &#123; for (const v of a) &#123; if (Array.isArray(v)) &#123; yield* flat(v); &#125; else &#123; yield v; &#125; &#125;&#125;const arr = [1, [[2, 3], 4], [5, 6]];for (var f of flat(arr)) &#123; console.log(f); // 1 2 3 4 5 6&#125; 8. async 函数 ES2017 标准引入了 async 函数，使得异步操作变得更加方便，但其实它只是 Generator 函数的语法糖。 Generator 函数其实本身也是异步操作的思想，因为 generator 函数里面每次只是完成一个 yield 及之前的代码，但是 generator 的异步实现比较麻烦在于其必须执行生成一个对象且执行其 next 方法才真的执行，语义上并不好理解，所以有了 async 函数。 async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 12345678910function timeout(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint(\"hello world\", 50); async 函数由于返回的是一个 promise 对象，所以 promise 对象的状态时 resolved 还是 rejected 取决于函数体内部的一些执行，很有意思的是，async 函数里只要有没有处理的错误（没有 catch）就会终止里面的运行转到外部的 catch 或者直接终止。所以如果希望 async 函数不会被中断，必须要传一个已经做过 catch 错误处理的 promise 函数，那样返回的就又是新的 resolved 的 promise 而不会中断后面的操作。 12345678910async function asyncFun() &#123; await new Promise((resolve, reject) =&gt; &#123; reject(\"throw error!\"); &#125;); console.log(\"done!\");&#125;const test = asyncFun(); // 此时不会执行到打印done这个语句test.catch(error =&gt; &#123; console.log(error); // throw error!&#125;); 9. ES6 的类—Class ES6 之前其实没有类的概念的，有的只是构造函数，我们有的时候趋向于把构造函数当作一个类，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 constructor 方法就是构造方法，而 this 关键字则代表实例对象，可以省略 constructor 方法。class 中的其他方法均是类的内部方法，是不可枚举的，这与常规的 ES5 通过在构造函数的 prototype 上新增类的方法其实是可枚举的是不同的。 12345678910111213141516171819202122class Point1 &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;typeof Point1; // \"function\"Point1 === Point1.prototype.constructor; // trueObject.keys(Point1.prototype); // []Object.getOwnPropertyNames(Point1.prototype); // [\"constructor\",\"toString\"]var Point2 = function(x, y) &#123; // ...&#125;;Point2.prototype.toString = function() &#123; // ...&#125;;Object.defineProperty(Point2.prototype, \"\");Object.keys(Point2.prototype); // [\"toString\"]Object.getOwnPropertyNames(Point2.prototype); // [\"constructor\",\"toString\"] 类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数是怎么调用的。 1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;Rectangle(); // Class constructor Rectangle cannot be invoked without 'new'const obj1 = new Rectangle(3, 4); // 输出 trueconst obj2 = new Square(3); // 输出 false 与函数一样，类也可以使用表达式的形式定义，其中类的名字只在 Class 的内部代码可用，指代当前类。且 class 和 function 不同的是，它定义的变量不存在变量提升，且和 let 或 const 一样不可重复定义。 123456789101112131415161718// 不存在变量提升new Foo(); // ReferenceErrorclass Foo &#123;&#125;// Me只能在class内部获取，且类的名字是MyClass而非Meconst MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;new Me(); // ReferenceError: Me is not definedMyClass.name; // \"Me\"new MyClass().getClassName(); // \"Me\"// 和 function 不同不可重复定义function a() &#123;&#125;function a() &#123;&#125;class a &#123;&#125; // SyntaxError: Identifier 'a' has already been declaredclass b &#123;&#125;class b &#123;&#125; // SyntaxError: Identifier 'b' has already been declared class 的私有方法：ES6 暂时没有私有方法和私有属性，只能通过变通方法模拟实现。 123456789101112131415161718192021222324252627282930313233// 一种做法是在命名上加以区别class Widget &#123; // 公有方法 foo(baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return (this.snaf = baz); &#125;&#125;// 私有方法移出模块，因为模块内部的所有方法都是对外可见的function bar(baz) &#123; return (this.snaf = baz);&#125;class Widget &#123; foo(...args) &#123; bar.apply(this, args); &#125;&#125;// 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值const bar = Symbol(\"bar\");const snaf = Symbol(\"snaf\");export default class myClass &#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return (this[snaf] = baz); &#125;&#125; class 的静态方法：静态方法是指不会被实例继承，而是直接通过类来调用的。ES5 的构造函数静态方法就是在构造函数自身挂载方法就可以了，而 class 的静态方法仍写在类里面，只不过用 static 关键字前面说明。目前 class 只有静态方法，没有静态属性。 12345678910111213// 由于静态方法是挂载在类本身上的，所以其函数内this指向的也是类本身而非类的prototypeclass Foo &#123; static bar() &#123; this.baz(); &#125; static baz() &#123; console.log(\"hello\"); &#125; baz() &#123; console.log(\"world\"); &#125;&#125;Foo.bar(); // hello ES6 之前的类的继承是通过原型链来实现的，基本思想是：把父类生成的实例加到子类的 prototype 属性上，如下： 123456789101112131415function Person() &#123;&#125;function Teacher() &#123;&#125;Person.prototype = &#123; constructor: Person, type: \"human\"&#125;;Teacher.prototype = Object.create(new Person(), &#123; constructor: &#123; value: Teacher, writable: true, configurable: true, enumerable: true &#125;&#125;);const t = new Teacher(); 而 class 的继承是定义子类通过 extends 关键字，和其内部利用 super 对象获取父类的一些东西。 子类的 constructor 可以省略，但是一旦不省略则必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。因为在子类的 constructor 方法中调用 super 方法后，相当于调用了父类的 constructor 方法生成了子类的实例，所以也只有在调用 super 方法之后也得不到 this。 12345678910111213141516171819202122232425262728293031323334class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static hello() &#123; console.log(\"hello world\"); &#125;&#125;// 忽略子类的constructor函数class ColorPoint1 extends Point &#123; getColorType() &#123; return \"point\"; &#125;&#125;// 和上面等价class ColorPoint2 extends Point &#123; constructor(...args) &#123; super(...args); &#125; getColorType() &#123; return \"point\"; &#125;&#125;// this必须要在super方法调用后才有class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125;// 父类的静态方法，也会被子类继承。ColorPoint.hello(); // hello world super 既可作为函数调用（仅可以在 constructor 中），也可作为对象读取属性和方法，那它分别指代的是什么呢，而运行时的 this 指代什么呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// super作为方法调用的是父类本身的构造函数，作为非方法在子类的非静态方法中相当于时父类.prototype，静态方法相当于父类本身// 子类调用父类的静态方法的this就是子类本身，而非静态方法是实例本身class A &#123; constructor() &#123; this.q = 2; this.x = \"super X\"; this.y = \"super Y\"; &#125; p() &#123; return 2; &#125; print() &#123; console.log(this.x, this.y); &#125; static print() &#123; console.log(this.z); &#125;&#125;A.z = \"A: zzz\";class B extends A &#123; constructor() &#123; super(); // 相当于A.prototype.constructor() console.log(super.p()); // 相当于时A.prototype，故返回2 this.x = \"sub X\"; &#125; get m() &#123; return super.q; // 相当于时A.prototype.q &#125; print1() &#123; super.print(); // 相当于A.prototype.print().call(this) &#125; static print2() &#123; super.print(); // 相当于A.print().call(this) &#125;&#125;let b = new B();b.m; // undefinedA.prototype.q = \"qq\";b.m; // qqb.print1(); // sub X super Y || this指向实例本身，它有自有属性x和继承属性yB.print(); // A: zzz || B本身没有print方法，但是B的原型链上一层是A，它有print方法，这时候this其实是A还是B？B，B没有自有属性z，但是有继承属性zB.print2(); // A: zzz || B通过super调用了A的print方法，这时候this其实是A还是B？B，B没有自有属性z，但是有继承属性zB.z = \"B: zzz\";B.print(); // B: zzz || 这里就证明了this指代的确实是B而非AB.print2(); // B: zzz || 这里就证明了this指代的确实是B而非A ES5 是先新建子类的实例对象 this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承。 123456789101112131415161718192021222324252627function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;);var colors = new MyArray();colors[0] = \"red\";colors.length; // 0colors.length = 0;colors[0]; // \"red\"class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length; // 1arr.length = 0;arr[0]; // undefined 10. Module 的语法 ES6 的模块是引入 import 和 export 两个命令来实现模块的引入和对外接口，比较需要主要的是接口语法和 import 的静态导入 import 和 export 命令可以出现在模块的任何位置（但是规范上当然出现在首尾），但是必须处于模块顶层，如果出现在块级作用域内就会报错。 import 和 export 的语法：export 只允许提供对外的接口。export default 可以允许直接输出一个常量出去，对应的 import 时直接可以以任何变量来引入。注意，和函数参数的解构不同，import 时是没有解构的，虽然看起来像解构，但是看 export default 的一个例子就知道。 123456789101112131415161718192021222324252627282930313233343536373839404142export var firstName = 'Michael';export function multiply(x, y) &#123; return x * y;&#125;;export class MyClass &#123;&#125;;// 和上面等价var firstName = 'Michael';function multiply(x, y) &#123; return x * y;&#125;class MyClass &#123;&#125;export &#123; firstName, multiply as changedFoo MyClass as changedClass&#125;// 以下都是错误export 1;var m = function () &#123;&#125;;export m;// 对应上面的importimport &#123;firstName, lastName, year&#125; from './profile.js';import &#123;firstName, changedFoo, changedClass&#125; from './profile.js';import &#123;firstName, lastName as new_name, year as new_year&#125; from './profile.js';// export defaultexport default &#123; firstName: 'Michael' lastName: 'Jackson'&#125;// 以下是正确的importimport anyName from './profile.js';// 以下是错误的import，因为import遇到大括号就会从export的接口去找对应的变量，而不是从export default的值去解构！！！import &#123;firstName, lastName&#125; from './profile.js';// 模块的整体加载，如下circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125;import * as circle from './circle'; ES6 模块与 CommonJS 模块的差异: CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用; CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 12345678910111213141516171819202122232425// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter&#125;;// main.jsvar mod = require(\"./lib\");console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 3// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from \"./lib\";console.log(counter); // 3incCounter();console.log(counter); // 4 11. 字符串的扩展 字符串基础知识：JS 的编码方式是基于 UTF-16 编码的，即把每一个字符用 16 进制的 Unicode 码点表示，如&quot;\\u0061&quot; === &quot;a&quot;，因为 a 在 ASCII 码表的序号是 97，换算成 16 进制即为 0x0061。所以这种表示法只限于码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。具体如何分解的参考js Unicode 码点问题; ES6 允许讲码点放进大括号，支持大于\\uFFFF 的字符。&quot;\\u{1F680}&quot; === &quot;\\uD83D\\uDE80&quot; 1234\"\\uD842\\uDFB7\"; // \"𠮷\"// 如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u00617），只会解析前4位\"\\u00617\"; // \"a7\"\"\\u&#123;20BB7&#125;\"; // \"𠮷\" 之前那些超过\\uFFFF 的码点，用字符串的 length 判断它会占用 2 个，但其实它应该只是一个。而且 ES6 之前的字符串方法 charAt()或者像类数组取[x]无法读取真正的字符，只会返回前两个字节和后两个字节的值。同样的还有 String.fromCharCode 方法不能识别 32 位的 UTF-16 字符。ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点，但是它仍是将其当做 2 个字符去处理，第一个返回整体的码点，第二个返回第二个字符的码点。还有String.fromCodePoint方法替代 String.fromCharCode 方法来处理 32 位的字符。 1234567891011121314// ES6之前的length和charAt方法处理不了4字节（2个16进制的Unicode码点）表示的字符\"𠮷\".length; // 2\"𠮷\"[0]; // \"�\"\"𠮷\".charAt(1); // \"�\"\"𠮷\".charCodeAt(0); // 55362，因为从上可以看出其前一个表示是\\uD842，2+16*4+8*256+13*4096 = 55362\"𠮷a\".codePointAt(0); // 134071\"𠮷a\".codePointAt(1); // 57271 === 0xDFB7\"𠮷a\".codePointAt(2); // 97// 判断字符是否是4字节字符function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xffff;&#125;String.fromCharCode(0x20bb7); // \"ஷ\"String.fromCodePoint(0x20bb7); // \"𠮷\" ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 for…of 循环遍历。for…of 遍历字符串最大的优点就是可以识别大于 0xFFFF 的码点 ES6 为字符串提供的新方法有 includes()、startWith()、endWith()、repeat()、padStart()、padEnd()方法，非常实用，例子如下： 1234567891011121314151617181920212223// includes、startWith、endWith三个方法都支持第二个参数，表示开始搜索的位置。const s = \"Hello world!\";s.startsWith(\"Hello\"); // trues.endsWith(\"d!\"); // trues.includes(\"o\"); // true// includes和startWith第二个参数是指从第n个位置直到字符串结束s.includes(\"Hello\", 6); // falses.startsWith(\"world\", 6); // true// endWith第二个参数是指针对前n个字符s.endsWith(\"Hello\", 5); // true// repeat方法返回一个新字符串，表示将原字符串重复n次\"x\".repeat(3); // \"xxx\"\"hello\".repeat(2); // \"hellohello\"\"na\".repeat(0); // \"\"// padStart()用于头部补全，padEnd()用于尾部补全\"x\".padStart(5, \"ab\"); // 'ababx'\"x\".padStart(4, \"abcdef\"); // 'abcx'\"x\".padEnd(5, \"ab\"); // 'xabab'\"x\".padEnd(4, \"abcdef\"); // 'xabc'\"xxx\".padStart(2, \"ab\"); // 'xxx'\"xxx\".padEnd(2, \"ab\"); // 'xxx'// padStart和padEnd省略第二个参数，默认使用空格补全长度\"x\".padStart(4); // ' x' ES6 提供的模板字符串（``标识）可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量，只需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性，甚至还能调用函数。 12345678910let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`; // \"1 + 2 = 3\"// 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中$(\"#list\").html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 12. 对象和数组的扩展 属性（包括方法）的简洁表示法 123456789101112131415const foo = \"bar\";const baz = &#123; foo &#125;;baz; // &#123;foo: \"bar\"&#125;const o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;; Object.is 方法也是用于比较两个值是否相等，和===的唯一区别是 NaN 和+0 与-0 1234+0 === -0; // trueNaN === NaN; // falseObject.is(+0, -0); // falseObject.is(NaN, NaN); // true Object.getOwnPropertyDescriptor 方法可以获取对象某个自有属性的描述对象，Object.getOwnPropertyDescriptors 方法可以获取对象全部自有属性的描述对象 123456789101112131415161718192021const obj = &#123; foo: 123, get bar() &#123; return \"abc\"; &#125;&#125;;Object.getOwnPropertyDescriptors(obj);//&#123;// foo:&#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125;,// bar:&#123;// get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true// &#125;//&#125; 对象实例的__proto__虽然在各个浏览器都有部署，但是其他运行环境不一定部署，所以 ES6 提供了新的 API 函数，Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作，ES5 已经有了）代替。 super 关键字：在对象的方法函数里，this 指代的是对象本身，ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。但是在写法上，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 12345678910111213141516171819202122232425262728const proto = &#123; foo: \"hello\"&#125;;const obj = &#123; foo: \"world\", find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find(); // \"hello\"// 报错const obj = &#123; foo: super.foo&#125;;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;;// 报错const obj = &#123; foo: function() &#123; return super.foo; &#125;&#125;; Object.assign(target, source1, source2, …)方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 Object.assign 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性。 12345678Object.assign( &#123; b: \"c\" &#125;, Object.defineProperty(&#123;&#125;, \"invisible\", &#123; enumerable: false, value: \"hello\" &#125;));// &#123; b: 'c' &#125; Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 1234const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b; // 2 Object.assign 可以用来处理数组，但是会把数组视为对象。 12Object.assign([1, 2, 3], [4, 5]);// [4, 5, 3] Object.assign 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。 12345678910111213const source1 = &#123; get foo1() &#123; return 1; &#125;&#125;;const source2 = &#123; get foo2() &#123; return this.a; &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source1, source2);// &#123;foo1: 1, foo2: undefined&#125; Object.keys()，Object.values()，Object.entries()分别返回对象可遍历的自有可枚举属性（即不含继承的且不含 Symbol 属性且 enumerable: true 的属性）的[key1, key2, …]、[value1, value2, …]、[[key1, value1], [key2, value2], …] 总结对于对象的遍历： for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 1234567891011Reflect.ownKeys(Object);// [\"length\", \"name\", \"prototype\", \"assign\", \"getOwnPropertyDescriptor\",//\"getOwnPropertyDescriptors\", \"getOwnPropertyNames\", \"getOwnPropertySymbols\",// \"is\", \"preventExtensions\", \"seal\", \"create\", \"defineProperties\",//\"defineProperty\", \"freeze\", \"getPrototypeOf\", \"setPrototypeOf\",//\"isExtensible\", \"isFrozen\", \"isSealed\", \"keys\", \"entries\", \"values\"]Reflect.ownKeys(Object.prototype);// [\"constructor\", \"__defineGetter__\", \"__defineSetter__\", \"hasOwnProperty\",//\"__lookupGetter__\", \"__lookupSetter__\", \"isPrototypeOf\",//\"propertyIsEnumerable\", \"toString\", \"valueOf\", \"__proto__\",//\"toLocaleString\"] Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） Array.of 方法用于将一组值，转换为数组。主要用来弥补数组构造函数 Array()的不足（因为参数个数的不同，会导致 Array()的行为有差异）。 数组实例的 find() 和 findIndex() ：find 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员，如果没有符合条件的成员，则返回 undefined。findIndex 和其一样只是返回下标或者-1。 数组实例的 includes()：基本用来取代 indexOf，因为其采用===，所以不能查找 NaN。对于+0 与-0 仍保持和===一致。 123[NaN].includes(NaN); // true[NaN].indexOf(NaN); // -1[+0].includes(-0); // true 13. 函数的扩展 函数参数支持传入默认值。 1234567891011121314function log(x, y = \"World\") &#123; console.log(x, y);&#125;log(\"Hello\"); // Hello Worldlog(\"Hello\", \"China\"); // Hello Chinalog(\"Hello\", \"\"); // Hellofunction foo(&#123; x, y = 5 &#125;) &#123; console.log(x, y);&#125;// 参数默认值可以与解构赋值的默认值，结合起来使用foo(&#123;&#125;); // undefined 5foo(&#123; x: 1 &#125;); // 1 5foo(&#123; x: 1, y: 2 &#125;); // 1 2foo(); // TypeError: Cannot read property 'x' of undefined 当传入默认值时，相当于在函数初始化参数解析时，参数会形成一个单独的作用域（context），是函数作用域的父作用域，是函数外层作用域的子作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567891011121314// 没有默认值时，x和函数作用域里面的处于相同作用域下，所以再次定义会报错let x = 1;function f(y) &#123; let y = 2; console.log(y);&#125;f(x); // SyntaxError: Identifier 'y' has already been declared// 含有默认值时，参数形成单独作用域，x引用的是外层作用域的1let x = 1;function f(y = x) &#123; let x = 2; console.log(y);&#125;f(); // 1 ES6 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 12345function doSomething(a, b = a) &#123; 'use strict'; // code&#125;// SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list ES6 引入了 rest 参数用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 12345678function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3); // 10 箭头函数（=&gt;）至于省略 return 时返回对象时必须加大括号都是注意事项，最主要的箭头函数和普通函数的区别有： 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象； 不可以当作构造函数 和 Generator 函数，也就是说，不可以使用 new 命令，否则会抛出一个错误； 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://dengxianyu.gitee.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://dengxianyu.gitee.io/tags/JavaScript/"},{"name":"进阶知识","slug":"进阶知识","permalink":"https://dengxianyu.gitee.io/tags/进阶知识/"}]},{"title":"再读犀牛书：JavaScript的基础知识集锦","date":"2018-06-14T09:30:11.000Z","path":"2018/06/14/再读犀牛书：JavaScript的基础知识集锦/","text":"1. new 一个构造函数，实际做了什么？ 创建一个新的空对象{}； 传入指定的参数，并且以这个新的空对象当做 this 来调用构造函数，以此来初始化新创建对象的属性； 一般的，构造函数不会返回一个值，而新创建的且被初始化后的对象就是整个表达式的值； 如果构造函数确实返回了一个对象值，那么这个对象值则是整个表达式的值，而新创建的对象则废弃了，如果是非对象值则一律返回新创建的且被初始化后的对象。 1234567891011121314151617var Foo1 = function() &#123; this.a = \"a\"; this.b = \"b\";&#125;;var Foo2 = function() &#123; this.a = \"a\"; this.b = \"b\"; return &#123;&#125;;&#125;;var Foo3 = function() &#123; this.a = \"a\"; this.b = \"b\"; return null;&#125;;new Foo1(); // =&gt; &#123; a: \"a\", b: \"b\" &#125;new Foo2(); // =&gt; &#123;&#125;new Foo3(); // =&gt; &#123; a: \"a\", b: \"b\" &#125; 2. 那些奇奇怪怪的运算符 2.1 typeof()返回什么？ 123456789// typeof(null)记住返回obejecttypeof undefined; // =&gt; \"undefined\"typeof null; // =&gt; \"obeject\"typeof true; // =&gt; \"boolean\"typeof 'abc'; // =&gt; \"string\"typeof 1000; // =&gt; \"number\"typeof NaN; // =&gt; \"number\"typeof []; // =&gt; \"obeject\"typeof (function foo()&#123;&#125;); // =&gt; \"function\" 2.2 toString()、valueOf()返回什么？ 普通的对象: 123// 继承Obeject本身的toString、valueOf方法(&#123;a:1&#125;).valueOf(); // =&gt; &#123;a:1&#125;(&#123;a:1&#125;).toString(); // =&gt; \"[object Object]\" 原生类： 123456789101112131415161718// 数组的toString返回每一个子项的toString并用逗号连接[1, true, &#123;&#125;].toString(); // =&gt; \"1,true,[object Object]\"new Date().toString(); // =&gt; \"Wed Nov 22 2017 09:32:55 GMT+0800 (中国标准时间)\"(function() &#123;return 'abc'&#125;).toString(); // \"function () &#123;return 'abc'&#125;\"(/[a-z]/i).toString(); // \"/[a-z]/i\"// Object.prototype.toString是常用的判断原生哪种类型的好方法Object.prototype.toString.call([]); // \"[object Array]\"Object.prototype.toString.call(/a/); // \"[object RegExp]\"Object.prototype.toString.call((function()&#123;&#125;)); // \"[object Function]\"// 用户自定义的类该方法无法识别function MyClass() &#123;&#125;;var a = new MyClass();Object.prototype.toString.call(a); // \"[object Object]\"// 除了Date类返回时间戳，其余全部返回对象自身(&#123;&#125;).valueOf(); // &#123;&#125;(fnction()&#123;&#125;).valueOf(); // ƒ ()&#123;&#125;[11].valueOf(); // [11]new Date().valueOf(); // =&gt; 1511314312177 一些特殊值： 12345678// undefined、null、普通数字是没有toString()方法的99.toString(); // 报错=&gt; SyntaxError(99).toString(); // \"99\"(99).toString(16); // \"63\"(99).toString(8); // \"143\"true.toString(); // =&gt; \"true\"NaN.toString(); // =&gt; \"NaN\"Infinity.toString(); // =&gt; \"Infinity\" 2.3 Boolean()中哪些返回了 false？ 123// if()语句、！操作符，都会调用Boolean()方法// 以下全是false，其余全是trueBoolean(undefined || null || false || \"\" || 0 || NaN); 2.4 String()中哪些特殊注意的？ 12345678// 字符串的拼接 + 会每个都是String()返回值相加'' + undefined + null; // =&gt; \"undefinednull\"undefined + null; // =&gt; 这时候调用数字加，返回NaN// 如果有toString方法，会返回其toString()方法的值String(undefined); // =&gt; \"undefined\"String(null); // =&gt; \"null\"String(99); // =&gt; \"99\"String([1, true, &#123;&#125;]); // 和toString()返回的一样=&gt; \"1,true,[object Object]\" 2.5 Number()中哪些特殊注意的？ 1234567891011// 数字 + 会是Number()返回值相加1 + undefined; // =&gt; NaN, Number(undefined)为NaN1 + null; // =&gt; 1, Number(null)为0Number(\"\"); // =&gt; 0Number(\" 1.23e-1 \"); // =&gt; \"0.123\", 去字符串两端空格并尽量转换Number(\"123a\"); // =&gt; NaN// 普通对象全是NaNNumber([]); // =&gt; 0Number([\" 1.23e-1 \"]); // =&gt; 0.123Number([\"1\", 2]); // =&gt; NaNNumber(new Date()); // =&gt; 1511352731707 2.6 String()、Number()中一个对象有什么规律？ 对象一般都先调用自己的 valueOf()方法，如果返回的是原始值，则基于这个原始值计算获得结果，如果 valueOf()方法返回是非原始值，则调用 toString()方法来获取原始值，然后计算获得结果！ 2.7 ===全等运算符的一些规则？ 如果两个值类型不相同，则它们不全等； null、undefined、true、false 仅仅与自身全等； NaN 与任何值都不全等，包括其本身，即 NaN === NaN 返回 false； 两个数字的数值相等，则其全等，即 0 === -0、Number.POSITIVE_INFINITY === Infinity 返回 true; 如果是对象，必须引用同一个对象才全等，否则不等； 2.8 ==相等运算符的一些规则？ 如果两个值类型相同，则会遵循全等去返回结果，类型不同的双方，会先做一些转换变成同类型，再遵循照全等去返回结果； null == undefined，除本身以及对方都不等； 如果一个是数字，另一个是字符串，会将字符串转换成数字（Number 方法），然后用转换后的值去进行比较，所以 0 == &quot;&quot;、 &quot;1.23e-1&quot; == 0.123 返回 true； 如果其中有一个是布尔值，则先将布尔值转换成 0 或 1，再按上述规则，所以&quot;0&quot; == false 返回 true； 如果其中有一个是对象，则先对象转换成原始值（先调用 valueOf()若返回不是原始值，则再调用 toString()），然后再按上述规则，所以[] == 0、[] == false 均返回 true； 2.9 &amp;&amp;和||的返回规则---短路规则 首先 JS 中的“假值”：false、null、undefined、0、-0、NaN、&quot;&quot;； &amp;&amp;的短路：第一个操作数是“假值”，则返回第一个操作数，不再进行第二个操作数的计算，第一个为非“假值”，返回第二个操作数的结果，所以(null &amp;&amp; abc) === null、&quot;abc&quot; &amp;&amp; &quot;abcd&quot; === &quot;abcd&quot;； ||的短路：和&amp;&amp;相反，第一个为“假值”，则返回第二个操作数… 3. 变量的“声明提前”是什么？ 变量的声明：变量的声明语句有两种，var 声明变量语句和 function 声明函数语句； 1234567var s = 'abc'; // var声明变量语句function foo() &#123;&#125; // function声明函数语句，结尾不能有分号var f = function() &#123;&#125;; // 匿名函数赋值给f，还是属于var声明变量语句// 函数表达式中的函数声明的函数名称，仅仅在函数体内有效，不会进去命名空间var vf = function tf() &#123;console.log(typeof tf)&#125;;vf(); // \"function\"tf; // 报错：Uncaught ReferenceError: foo is not defined 解释：变量在它们定义的脚本或者函数中的声明语句（但不涉及赋值）都被“提前”至脚本或者函数的顶部，优先级函数声明 &gt; 形参定义 &gt; 函数声明； 12345678910111213function g(arg1, arg2) &#123; var arg1; console.log(arg1); // \"abc\"，形参的命名优先级大于声明语句 var arg2 = \"abcd\"; console.log(arg2); // \"abcd\"，形参是可以被重新赋值取代的 console.log(s); // \"undefined\"，不会throw ReferenceError console.log(typeof tf); // \"function\"，函数声明即定义了tf的值 console.log(vf); // \"undefined\"，仅仅算变量声明 var s = 'abc'; var vf = function() &#123;&#125;; function tf() &#123;&#125;&#125;g('abc', 'abc'); 4. Object 对象的属性：分为“数据属性(data property)”和“存储器属性(accessor property)”； 数据属性就是一个简单的值（null，字符串，对象等都算普通值），其属性的特性有 value、writable、enumerable、configurable； 存储器属性的属性值是用 getter 和 setter 两个方法定义的，其属性的特性有 get、set、enumerable、configurable； 对象的继承：对象具有“自有属性”，也有一些从原型对象继承而来的属性，即“继承属性”；继承的方式主要是三种，第一种对象直接量的形式是直接继承了 Object.prototype 属性;构造函数形式生成的对象继承了其构造函数的 prototype 属性，而 Object.create()方法生成的对象继承了该方法的第一个参数（可以为 null，但不允许为 undefined）。我们通常把继承的属性称之为对象的“原型对象”； 对象的类：ES5 本身没有类，但是通常我们把构造函数的名字称之为类的名字，js 内置的就有 Array 类、RegExp 类、Date 类，Error 类等，如上我们就构造了一个 ConstructorFoo 的类； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 1. 构造函数的方式实现对象的继承function ConstructorFoo(obj) &#123; for(var p in obj) &#123; this[p] = obj[p]; &#125;&#125;var inheritObj = &#123; inheritP: 1&#125;;ConstructorFoo.prototype = inheritObj;var son1 = new ConstructorFoo(&#123;p:100&#125;);son1.p; // 100son1.inheritP; // 1// 2. Object.create()方法实现对象的继承var son2 = Object.create(&#123;inheritP: 2&#125;);son2.inheritP; // 2// 对象直接量和直接o.x=1这种设置的属性，writable、enumerable、configurable都默认为true，getOwnPropertyDescriptor只能查自有属性的属性特性Object.getOwnPropertyDescriptor(son1, 'p'); // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(son1, 'inheritP'); // undefined// 如果用Object.defineProperty(ies)方法创建的属性，则未设置的都默认为数据属性，value为undefined，其余为falseObject.defineProperty(son1, 'a', &#123;&#125;);Object.getOwnPropertyDescriptor(son1, 'a'); // &#123;value: undefined, writable: false, enumerable: false, configurable: false&#125;//ES3中定义一个存储器属性，（IE以外）都已经实现的get和set写法，其中写法不能为get next: function()...。getter和setter中的this为对象本身。var serialnum = &#123; $n: 0, get next() &#123; return this.$n++&#125;, set next(n) &#123; if (n &gt;= this.$n) this.$n = n; else throw \"序列号的值不能比当前值小\"; &#125;&#125;;// ES5中定义一个存储器属性，自然就是用Object.defineProperty(ies)方法Object.defineProperties(son1, &#123; x: &#123; value: 1, writable: true, enumeable: true, configurable: true &#125;, y: &#123; value: 1, writable: true, enumeable: true, configurable: true &#125;, r: &#123; get: function() &#123; return Math.sqrt(this.x*this.x + this.y*this.y) &#125;, enumerable: true, configurable: true &#125;&#125;);// 判断一个属性是否存在于对象中，是其自有属性还是继承属性？// 1. in运算符'p' in son1; 'inheritP' in son1; // 皆true,// 2. 对象的继承方法hasOwnProperty，仅仅是自有属性才返回trueson1.hasOwnProperty('inheritP') // false// 3. for/in循环遍历了对象自有属性和继承属性中所有可枚举(enumerable为true)的属性for(var p in son1) console.log(p); // p inheritP// 4. 对象的继承方法propertyIsEnumerable，仅当是自有属性且是可枚举的返回trueson1.propertyIsEnumerable('inheritP'); // false// 判断对象的原型对象Object.getPrototypeOf(son1); // &#123; inheritP: 1 &#125;inheritObj.isPrototypeOf(son1); // trueObject.prototype.isPrototypeOf(son1); // true 5. Array 数组的最后一个逗号和对象是一样的，可以省略，所以其 length 的判断要注意； 12[,].length; // 1[1,,3].length; // 3 由于数组是对象生成的子类，所以[]里的不止可以是数组索引，还可以是字符串，但是仅仅[]中的值和一个数字非负整数相等或者是非负整数的字符串，才会计入数组的队列中，有可能修改其 length，其余的都当做普通属性处理； 123a[-1.23] = true; // 创建了一个名为\"-1.23\"的属性a['1000'] = true; // 数组的第1001个元素为truea[1.000] = 1; // 数组的第二个元素，和a[1]相等 Array.prototype 上给所有数组实例继承的方法可分为三类，一类是不改变数组本身的，主要依赖其 return 值来获取新的结果，包括 join、concat、slice、indexOf、lastIndexOf；另一类是改变了数组本身的，包括 reverse、sort、splice、push、pop、unshift、shift；还有 ES5 新增的 forEach、map、filter、every、some、reduce、reduceRight； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// join方法不传参默认为逗号，它会将每个元素先转化成字符串再用参数的字符去连接[1, 2].join(); // \"1,2,c\"[1, [2, 'c']].join('__'); // \"1__2,c\"[,,].join('__'); // \"__\"[undefined,null].join('__'); // \"__\"// concat方法支持传多个参数，参数可以是数组和非数组，当时数组时会将其每个都加入而非整体，非数组直接加到后面[1].concat(2, [3, 4], [5, [6, 7]]); // [1, 2, 3, 4, 5, [6, 7]];// slice方法将数组的一部分返回回来，两个参数分别表示起点和终点，返回的结果不包括终点；若忽略第二个参数，默认表示到结尾var a = [1, 2, 3, 4, 5];a.slice(0,3); // [1, 2, 3]a.slice(3,2); // []a.slice(2); // [3, 4, 5]a.slice(0,-1); // [1, 2, 3, 4]// indexOf和lastIndexOf查找(全等匹配)数组中某个元素的索引值，查找到第一个就返回不再查找，若查找失败则返回-1，lastIndexOf从数组末尾查，这个方法在数组和字符串的效果是一样的，且可以传第二个参数来表示查找位置var a = [1, 2, 3, 4, 5, 4, 3, 2, 1];a.indexOf(3); // 2a.lastIndexOf(3); // 6a.indexOf(5); // 4a.indexOf(5, 4); // 4a.indexOf(5, 5); // -1// sort方法是将数组排序，默认会以字母表顺序排序（排序本身没说明就是以小到大），可以传一个函数，假如第一个参数在前则返回小于0的数值，反之返回大于0的数值var a = [33, 4, 1111, 222];a.sort(); // 返回新的a，此时a为[1111, 222, 33, 4]a = [33, 4, 1111, 222];a.sort(function(pre, next) &#123; return pre - next&#125; ); // [4, 33, 222, 1111]// splice方法是将数组指定位置增删的方法，第一个参数表示起点，第二个参数表示准备删除元素的个数，后面的参数是准备增加新元素，返回的是被删除元素组成的数组var a = [1, 2, 3, 4, 5, 6, 7, 8]a.splice(4); // 返回[5, 6, 7, 8]; a现在是[1, 2, 3, 4]a.splice(-1); // 返回[4]; a现在是[1, 2, 3]a.splice(1, 2); // 返回[2, 3]; a现在是[1]a.splice(0, 0, 3, 2); // 返回[]; a现在是[3, 2, 1]a.splice(1000, 5, 0); // 返回[]; a现在是[3, 2, 1, 0]; 若起点大于length，则为数组末尾进行删增操作a.splice(-1000, 5, 0); // 返回[3, 2, 1, 0]; a现在是[0]; 若起点小于-length，则为数组开头进行删增操作// forEach方法的参数function的三个参数value, index, array，其中value是array[index]全等的，但是修改其相当于ES6的const定义，不可重新赋值var a = [&#123; x: 1 &#125;, &#123; y:2 &#125;];a.forEach((v, i ,a) =&gt; &#123; console.log(v === a[i]);&#125;); // true, truea.forEach((v, i ,a) =&gt; &#123; v.x &amp;&amp; (v.x = 2);&#125;) // a现在是[&#123; x: 2 &#125;, &#123; y:2 &#125;]a = [1, 2, 3, 4, 5];a.forEach((v, i ,a) =&gt; &#123; v = v + 1;&#125;) // a现在仍是[1, 2, 3, 4, 5]a.forEach((v, i ,a) =&gt; &#123; a[i] = v + 1;&#125;) // a现在是[2, 3, 4, 5, 6] Array 构造函数上的方法，Array.isArray()，判断是否是数组 6. Function 变量的作用域：指的是变量可以被引用的区域。C 语言类的编程语言都是有块级作用域的，即花括号{}内的代码具有各自的作用域，变量在声明它们之外的代码里是不可见的。JavaScript 没有块级作用域，取而代之的是函数作用域。 函数作用域顾名思义就是函数块里形成一个外界不可见的作用域。全局变量在程序中始终都是有定义的，局部变量在声明它的函数体内以及所嵌套的函数体内是有定义的。 全局对象和局部对象：JavaScript 的全局变量实际上是全局对象的一个属性，ES5 把全局对象称为“声明上下文对象”。全局对象可以通过 this 关键字来引用。而局部对象可以说是函数作用域内的存储着局部变量的一些属性，局部对象是我们不可见的内部实现。 词法作用域：也叫静态作用域，它的作用域是指在词法分析（定义）阶段就确定了，不会改变。 作用域链：每一个局部作用域都会产生一个与之关联的作用域链，可以把它看作一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。在 JavaScript 最顶层代码中，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象（即局部对象），第二个是全局对象；在一个嵌套的函数体内，作用域链上至少有三个对象。在定义一个函数时，实际上保存着一个作用域链。 这一块还是看一下大神的文章比较清晰：https://github.com/mqyqingfeng/Blog/issues/3 1234567891011121314// foo在定义成，其var a = 2;function foo() &#123; console.log(a); // 会输出2还是3？&#125;function bar() &#123; var a = 3; foo(); function inner() &#123; console.log(a++); // 会输出2还是3？ &#125; inner();&#125;bar(); // 2 3 函数定义的两种方式：函数表达式和函数声明语句。函数名和形参只是函数内部的一个局部变量。 函数表达式也可以包含函数名称的变量有声明提前，但是真正的赋值仍是没有提前的，所以必须在赋值语句之后才能调用，而函数声明语句会声明提前，相当于在作用域顶部就定义了 var fooName = function fooName(){…}，所以函数声明语句无论在作用域的什么地方定义，其调用都是可以在作用域的任何地方。值得注意的是，函数声明语句不能出现在循环、条件判断或者 try/catch/finally 的语句中。 函数调用的四种方式，以及每种方式中函数体内的 this 关键字的指代。若是 bind 方法绑定过的函数，则无论怎样调用方式，其值仍是 bind 的那个对象。但是需要注意的是 bind 方法不会改变原函数，而会返回一个绑定后的新函数！具体见示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 1. 作为函数直接调用，非严格模式下this是全局变量，严格模式下是undefinedvar a = 1;function returnA() &#123; return this.a; &#125;;returnA(); // 1// 2. 作为方法，this是其调用的对象var obj = &#123; a: 2, myMethod: returnA &#125;;obj.myMethod(); // 2// 3. 作为构造函数，也就是new之后去调用，this只带一个初始化的空对象，见之前“new一个构造函数，实际做了什么？”// 4. 通过call()和apply()方法间接调用，this是第一个参数var anotherObj = &#123; a: 3 &#125;;returnA.call(anotherObj); // 3obj.myMethod.call(anotherObj); // 3// 综合示例1var o = &#123; m: function() &#123; var self = this; console.log(this === o); // true，this f(); function f() &#123; console.log(this === o); // false，this在浏览器环境下是window console.log(self === o); // true，闭包 &#125; &#125;&#125;;o.m(); // 输出如上// call方法的运用var outer = &#123;&#125;;var o = &#123; m: function() &#123; console.log(this === outer); f(); function f() &#123; console.log(this === window); &#125; &#125;&#125;;o.m.call(outer); // true, true// bind无法直接在函数声明语句后加var outer1 = &#123;&#125;;var outer2 = &#123;&#125;;var o = &#123; m: (function() &#123; console.log(this === outer2); f(); (function f() &#123; console.log(this === outer1); &#125;).bind(outer1) &#125;).bind(outer2)&#125;;o.m.call(outer); // 语法报错！// bind对于原函数无影响，会返回一个绑定this后的函数，且不受call方法影响！var outer1 = &#123;&#125;;var outer2 = &#123;&#125;;var o = &#123; m: (function() &#123; console.log(this === outer2); f.bind(outer1); f(); function f() &#123; console.log(this === window); console.log(this === outer1); &#125; var g = f.bind(outer1); g(); &#125;).bind(outer2)&#125;;o.m.call(outer) // true true false false true 函数的 arguments----函数内指向实参对象的引用(所以改变 arguments 也会改变实参，反之亦然)。它是一个类数组对象。它还有两个属性，callee 属性指代当前正在执行的函数，caller 指向正在执行的函数的函数。 12345678910111213141516function f(x) &#123; console.log(x, arguments[0]); arguments[0] = 1; console.log(x, arguments[0]); x = 2; console.log(x, arguments[0]);&#125;f(0); // 0 0 1 1 2 2var o = &#123; factorial: function(x) &#123; if (x &lt;= 1) return 1; return x * arguments.callee(x-1); &#125;&#125;;o.factorial(5); // 120 匿名函数：由于函数形成的代码块形成了一个局部作用域，所以有的时候为了怕对全局代码造成变量污染，匿名函数就显得特别常见。(function(){…}())。闭包和匿名函数一起可以实现对于局部变量的保存。 1234567891011121314151617// 从0开始，每次运行一次就加1；var uniqueInteger = (function() &#123; var counter = 0; return function() &#123; return counter++ &#125;;&#125;());uniqueInteger(); // 0;uniqueInteger(); // 1;// 定义一个函数，每个函数都var func = [];for(var i = 0; i &lt; 3; i++) &#123; func[i] = (function(i) &#123; return function() &#123; return i &#125;; &#125;)(i);&#125;func[0](); // 0func[1](); // 1 函数的 length 属性：表示函数形参的个数，而 arguments 的 length 表示实参的个数 7. 类和模块 类：ES6 之前，JS 没有类的概念，但是是可以实现类。类的实现是基于其原型继承机制的，如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例，所以原型对象是类的唯一标识。 构造函数：构造函数是“类”的外在表现，构造函数的名字通常用作类名，比如 Range()构造函数创建了 Range 类的对象。 instanceof：检查一个对象是不是属于某个类或者其子类，比如 123var r = new Range();r instanceof Range; // true;r instanceof Object; // true，因为Range是Object的子类 8. 正则表达式 字符：JavaScript 采用 UTF-16 编码的 Unicode 字符集，JavaScript 字符串是由一组无符号的 16 位值组成的序列。 创建：正则表达式直接量创建/\\d/，或者 RegExp 构造函数创建 new RegExp('\\\\\\d')。在 ES3 中，除 IE 外的其他浏览器全都对于正则表达式直接量创建的是共享一个实例，ES5 修正这种不合理。 正则表达式中的特殊意义字符：^ $ . ? * + = ! : | \\ / ( ) [ ] { } 当启用重复模式时，默认是“贪婪匹配”，如要非贪婪匹配，需要在重复字符后加一个?即可 字符 匹配规则 示例 […] 方括号内任意字符 'abc'.match(/[a-z]/g) 结果 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] [^…] 不在方括号内的任意字符 'abc!'.match(/[^\\!]/g) 结果 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] . 除换行符合其他 Unicode 终止符的任意字符 'abc!\\n'.match(/./g) 结果 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;!&quot;] \\w 匹配字母、数组和下划线，等价于[_a-zA-Z0-9] &quot;i don't&quot;.match(/\\w/g) 结果 [&quot;i&quot;, &quot; &quot;, &quot;d&quot;, &quot;o&quot;, &quot;n&quot;, &quot;t&quot;] \\W \\w 的逆运算 &quot;i don't&quot;.match(/[^\\w]/g) 结果 [&quot;'&quot;] \\s 任何 Unicode 空白符 &quot;i don't\\n&quot;.match(/\\s/g) 结果 [&quot; &quot;, &quot;\\u000A&quot;] \\d 任何 ASCII 数字，等价于[0-9] &quot;1.23&quot;.match(/\\d/g) 结果 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] \\D \\d 的逆运算 {m,n} m ≤ 匹配前一项 ≤ n， 切记逗号后不能有空格！ /\\d{2,3}/.exec('1234') 结果 [&quot;123&quot;] {m,} 匹配前一项 ≥ m /\\d{1,}/.exec('1234') 结果 [&quot;1234&quot;] {m} 匹配前一项 = m ？*+ ?是{0,1} *是{0,} +是{1,} /\\d+?/.exec('1234') 结果 [&quot;1&quot;] (…) 组合，将几个项组合成一个单元，这个单元可通过*、+、？、|等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后引用和使用 /(\\d){3}aaa/.exec('222aaas') 结果 [&quot;222aaa&quot;, &quot;2&quot;] | 选择，匹配的是该符号左边的子表达式或右边的子表达式 /(ab\\|cd)o|abcd/可以匹配出 abo、cdo、abcd (?:…) 只组合，把项组合成一个单元，但不记忆与该组相匹配的字符 \\n 和第 n 个分组第一次匹配的字符相匹配 /(['&quot;])[^\\1]*\\1/可以匹配成对的单引号或者双引号 ^和$ 匹配字符串的开头和结尾，在多行检测中检测一行的开头的结尾 /^abc$/仅仅匹配 abc \\b 匹配一个单词的边界 /\\bjava\\b/.test(java is bad)为 true，/\\bjava\\b/.test('javascript')为 false \\B 匹配非单词的边界 /\\Bjava\\B/.test('javascript')为 true (?=p) 零宽正向先行断言 /java(?=\\:)/.exec('java: good')结果为[&quot;java&quot;] (?!p) 零宽负向先行断言 /java(?!\\:)/.exec('java is good')结果为[&quot;java&quot;]，/java(?!$)/.exec('i love java')结果为 null String 类型中可以用正则当参数的方法有 search、replace、match、split。 字符 替换 $n 匹配第 n(1,2,3…)个 regexp 中的圆括号字表达式的文本 $&amp; 匹配结果 $` 匹配结果的左边文本 $' 匹配结果的右边文本 $$ 美元符号$ 12345678910111213// search方法不支持全局搜索，返回最先匹配到的下标值或者-1\"JavaScript\".search(/srcipt/i) // 4// replace方法主要是第二个参数，若为字符串支持$n、$&amp;、$`、$'、$$，还支持函数`i say: \"hello!\"`.replace(/([\"'])([^\\1]*)\\1/, \"$&amp; yes\") // `\"i say: \"hello!\" yes``i say: \"hello!\"`.replace(/([\"'])([^\\1]*)\\1/, \"$1 yes\") // `i say: \" yes``i say: \"hello!\"`.replace(/([\"'])([^\\1]*)\\1/, \"'$2' yes\") // `i say: 'hello!' yes``i say: \"hello!\"`.replace(/([\"'])([^\\1]*)\\1/, `\"$3 yes\"`) // `i say: \"$3 yes\"``i say: \"hello!\"`.replace(/([\"'])([^\\1]*)\\1/, \"$$3\") // \"i say: $3\"// match方法是最常用的，若参数正则带g，则返回全局匹配所有匹配结果，否则返回匹配第一个的结果和子结果的集合组数，若为返回null\"1 plus 2 equals 3\".match(/\\d/g) // [\"1\", \"2\", \"3\"]\"my blog at https://www.github.com/dengxy#blog\".match(/(\\w+)\\:\\/\\/([\\w\\.]+)\\/(\\S*)/)// [\"https://www.github.com/dengxy#blog\", \"https\", \"www.github.com\", \"dengxy#blog\"]// split指定分隔符\"1, 2，3,4,,5\".split(/[,，\\s]+/) // [\"1\", \"2\", \"3\", \"4\", \"5\"] RegExp 的属性和方法 exec 方法，若参数带有 g，则会将正则表达式的 lastIndex 属性设置为紧挨着匹配子串的字符位置，然后下一次的调用就会从该位置开始去匹配字符串，每次若有返回结果返回匹配结果和子串的数组集合，若没有匹配结果则返回 null，且将 lastIndex 重置为 0。若不带有 g，lastIndex 永远都是 0，会从起始位置开始匹配。 test 方法，和 exec 同等的过程，只是返回结果 exec 若返回非 null 则其返回 true，否则返回 false。 属性 说明 source String，只读，正则表达式的文本 global Boolean，只读，表明正则表达式是否带有修饰符 g ignoreCase Boolean，只读，表明正则表达式是否带有修饰符 i multiline Boolean，只读，表明正则表达式是否带有修饰符 m lastIndex Number，可读写，表示正则表达式下次检索的开始位置 练习题 写一个函数 getCamelCase，将当前传入的 string 由-连接式变成驼峰命名法则。 写一个函数 getQuery，获取当前 URL 的查询参数并返回一个对象，同一个查询参数若有多个值则封装成数组。若没有返回{}。 写一个函数 testIPV4，检测当前字符串是否为合法的 ipv4 地址（0.0.0.0~255.255.255.255）。 写一个函数 getMostFrequentWord，检测一篇文章中英文单词出现次数最多的单词和其次数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function getCamelCase(str) &#123; return str.replace(/-(\\w)/g, ($, $1) =&gt; &#123; return $1.toUpperCase(); &#125;)&#125;function getQuery() &#123; const search = decodeURI(location.search); const pattern = /\\??(\\w+)=(\\w+)&amp;?/g; const query = &#123;&#125;; let res; while((res = pattern.exec(search)) !== null) &#123; const v = query[res[1]]; if(v) &#123; if(Array.isArray(v)) &#123; v.push(res[2]); &#125; else &#123; query[res[1]] = [v, res[2]]; &#125; &#125; else &#123; query[res[1]] = res[2]; &#125; &#125; return query;&#125;function(str) &#123; const pattern = /^([1-9]|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])\\.([1-9]|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])\\.([1-9]|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])\\.([1-9]|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])$/; return pattern.test(str);&#125;function getMostFrequentWord(article) &#123; const allWords = article.match(/\\b[\\w']+\\b/gmi); const countObj = &#123;&#125;; for(let i = 0, len = allWords.length;i &lt; len; i++) &#123; const curWord = allWords[i]; if (curWord in countObj) &#123; ++countObj[curWord]; &#125; else &#123; countObj[curWord] = 1; &#125; &#125; let frequency = 0; let mostFrequentWord = ''; for(const key in countObj) &#123; if(countObj[key] &gt; frequency) &#123; frequency = countObj[key]; mostFrequentWord = key; &#125; &#125; return &#123; mostFrequentWord, frequency &#125;&#125; 9. Window 对象 setTimeout 和 setInterval，用于异步指定时间执行的，返回的值可以供 clearTimeout 和 clearInterval 当做参数去取消后续函数的调用。 location 对象，表示当前窗口中当前显示的文档 URL，并且提供方法使窗口载入新的文档。 href 属性：包含 URL 的完整文本，如https://www.baidu.com/wenku/index.html?q=Javascript&amp;user=dengxy#results protocol 属性：协议，&quot;https&quot;或者&quot;http&quot; hostname 属性: 主机名，如上是&quot;www.baidu.com&quot; port 属性：端口部分，如上是&quot;&quot; host 属性: 主机名+端口部分。比如&quot;www.baidu.com:8080&quot; pathname 属性：路径名部分，如上是&quot;/wenku/index.html&quot; search 属性：查询部分，如上是&quot;?q=Javascript&amp;user=dengxy&quot; hash 属性：hash 值部分，如上是&quot;#results&quot; origin 属性：只读，域名的标准形式，如上是&quot;https://www.baidu.com&quot; assign 方法：载入指定 url，如 location.assign(’/wangpai/index.html’)会自动把 URL 的 pathname 以及后面的替换，location.assign('https://www.baidu.com')会把整个 URL 替换。 replace 方法：也是载入指定 url，但是在载入新文档之前会从浏览历史中把当前文档删除。 reload 方法：浏览器重新载入当前文档。 location 直接赋值：虽然 location 本身是对象，但是仍可以赋值一个 url 方式实现跳转，和虽然这个 assign 方法一样的效果，但是仍很扯。 history：back、forward 方法来前进和后退，go()支持传参一次前进和后退任意多个页面 iframe 产生的多个独立的 window 对象，每一个都有一个 self 引用于自己的 window。top 表示最顶层的 window 对象，parent 表示当前窗体的父窗口，所以在顶层窗口肯定是 self===top===parent 的。iframe 的 window 引用也有多种途径，可以通过 frame[0]、frame[1]分别引用当前窗口第 1 个和第二个子窗体的 window 对象，也可以通过 frame[子窗体的 name/子窗体的 id]这样。还可以通过 iframe 的 DOM 元素 contenWindow 属性。 10. document 对象 获取元素的原生 JS 方法： document.getElementById 返回的是一个 Element 对象实例，若未查找到则返回 null； document.getElementsByName/getElementsByTagName/getElementsByClassName 返回的是 NodeList 对象实例，是 Element 对象实例的集合。无论是 Element 对象还是 NodeList 对象都和 document 实时挂钩，所以每一次的读写都是实时地获取或操作文档，尤其是 NodeList 对象每次都会重新更新其内容，比如 const aDom = document.getElementsByTagName('a');将 document 中再加一个 a 元素，aDom 也会更新成包括新加的列表 。所以一般的，把 NodeList 对象转化成普通数组以便调用，Array.prototype.slice.call(nodelist); document.querySelector/querySelectorAll 支持传参和 css 选择器语法保持一致，所以异常强大，如 document.querySelector(’#id’), document.querySelectorAll('p[lang=&quot;fr&quot;]');但是 querySelectorAll 其返回的是查询是 document 的快照结果，不会实时更新。 元素节点对象上一些有用的属性： 自己在 DOM 树中一些位置相关属性：如 parentNode 表示其父节点元素，childNodes 表示其子节点的实时表示的 NodeList 对象，firstChild/lastChild 分别为子节点的第一个/最后一个，nextSibling/previoursSibling 分别表示其兄弟节点的下一个/上一个，nodeType 表示其节点类型(9 表示 document 节点，1 表示 Element 节点，3 表示 Text 节点等)，nodeValue 表示 Text 节点或 Comment 节点的内容 实际上只是关心 Element 节点的 API：children 表示子节点中仅仅是 Element 节点的列表，同理还有 firstElementChild/lastElementChild/nextElementSibling/previousElementSibling 元素的标准 HTML 属性和非标准 HTML 属性：元素本身有一些通用的属性，如 id、name、className、style 等每个元素设置都有作用的，注意 id 是全局唯一的，且设置后立即会变成全局属性放 window 下，style 属性是一个对象，而有些元素是例如一个 script 标签元素或者 a 标签元素，其 src 属性是该标签很重要的属性，radio/checkbox 类型的 input 类型其 name、type、defaultChecked 和 checked 属性，需要注意的是所有的属性都会有一个转化，如 max-length 转化成属性变成了 maxLength。元素的非标准属性，如在 div 上加一个 max-length 属性，该元素对象的 maxLength 其实是无法获取到的，可以借助 getAttribute、setAttribute、hasAttribute 和 removeAttribute 方法，它们可以获取和设置标准属性和非标准属性，但是 getAttribute 和标准属性获取的结果不同的是它们返回的结果是字符串，而标准属性获取到的可以是布尔值(defaultChecked、checked)、数值(maxLength)、字符串(id、name、type)甚至对象(style)。 HTML5 的标准 data 属性获取和设置：dataset 属性，如 data-x=“0”的获取是 Element.dataset.x，返回的也是字符串不能是其他类型的值，若想删除某个 data 属性，可以 delete Element.dataset.x 即可删除该属性。注意的是带连字符的属性对应于驼峰命名法，如 data-jquery-test 属性就变成了 dataset.jqueryTest 属性。 元素的内容属性：例&lt;p id=&quot;test&quot;&gt;我是一个&lt;i&gt;好&lt;/i&gt;人&lt;/p&gt;，则 test.innerHTML 属性结果返回&quot;我是一个&lt;i&gt;好&lt;/i&gt;人&quot;，test.outerHTML 属性结果为&quot;&lt;p id=&quot;test&quot;&gt;我是一个&lt;i&gt;好人&lt;/p&gt;&quot;，test.textContent 属性结果为&quot;我是一个好人&quot;，而且这些属性都是可读写的。尤其有意思的是 innerHTML 和 textContent 的区别，test.innerHTML=&quot;我是一个&lt;i&gt;好&lt;/i&gt;人&quot;，元素没有更改，但是 test.textContent=&quot;我是一个&lt;i&gt;好&lt;/i&gt;人&quot;，元素会显式地出现&lt;i&gt;和&lt;/i&gt;，所以 textContent 属性有利于防止 xss 攻击。 document 对象的方法： 对 DOM 节点的操作：元素的创建涉及 document.createElement/createTextNode/createDocumentFragment 方法，其中 createDocumentFragment 的特殊之处在于它使得一组节点被当做一个节点看待：如果其当做参数传到 appendChild()、insetBefore()中，其实是将该文档片段的所有子节点插入到文档中，而非片段本身。 元素的插入和删除：元素的插入涉及 appendChild、insetBefore 方法，它们的第一个参数都是要插入的元素，insetBefore 方法必须传第二个参数，表示要传插入哪位元素前面。若调用的是一个已经存在文档中的节点，那么那个节点会自动从它当前位置删除并在新的位置重新插入。removeChild 和 replaceChild 都是在父元素上调用。 练习题 写一个函数 setMask,为元素加一个蒙层，使其有 opacity 的不透明度且点击无反应。 写一个函数 appendToBody ipv4 地址（0.0.0.0~255.255.255.255）。 1234567891011121314151617181920212223242526272829function setMask(dom, opacity) &#123; dom.style.position = 'relative'; const maskDom = document.createElement('div'); maskDom.style.position = 'absolute'; maskDom.style.top = 0; maskDom.style.left= 0; maskDom.style.width =`$&#123;dom.clientWidth&#125;px`; maskDom.style.height =`$&#123;dom.clientHeight&#125;px`; maskDom.style.backgroundColor =`rgba(0,0,0,$&#123;opacity&#125;)`; maskDom.addEventListener('click', e =&gt; &#123; e.stopPropagation(); &#125;); dom.appendChild(maskDom);&#125;function appendToBody() &#123; const ulDom = document.getElementsByTagName('ul')[0]; const frag = document.createDocumentFragment(); for(let i = 1; i &lt; 1001; i++) &#123; const li = document.createElement('li'); li.textContent = i; frag.appendChild(li); &#125; ulDom.appendChild(frag); ulDom.addEventListener('click', e =&gt; &#123; if (e.target === e.currentTarget) return; alert(e.target.textContent); &#125;);&#125; 11. 浏览器事件 浏览器事件传播的三个阶段：第一阶段：事件捕获阶段，是指浏览器从根元素开始一直从 DOM 往下到目标对象的事件处理过程(对应于 addEventListener 第三个参数为 true)；第二阶段，目标对象处理阶段，是目标对象本身的事件处理程序；第三阶段，事件冒泡阶段，指事件又会从目标元素到根元素的冒泡事件处理过程(对应于 addEventListener 第三个参数为 false 或者不传)。 事件注册与注销：现代浏览器所有的文档元素都有一个标准方法 addEventListener，其第一个参数为事件名称（click, mouseenter），第二个参数为 Function，第三个参数定义事件是否是在事件捕获阶段，不传为相当于 false 即在事件冒泡阶段，相应的注销函数为 removeEventListener。IE9 之前不支持 addEventListener 和 removeEventListener，也不支持事件捕获，相对应提供了 attachEvent 和 detachEvent 方法，但是其第一个参数要加 on（onclick, onmouseover）。 事件处理函数：addEventListener 的第二个参数为函数，其默认有一个参数为 event 对象，其 type 属性即为事件的名称，函数的 this===e.currentTarget，表示当前捕获或者冒泡到的元素对象，而 e.target 则为事件的触发元素，如子元素 li 触发的 click，冒泡到父元素 ul，则 e.target 是 li，e.currentTarget 是 ul。 阻止事件默认行为和阻止事件传播：有一些事件会触发浏览器的默认操作，可以通过上面说的事件处理函数的参数 event 调用 preventDefault 方法来取消默认行为，而 IE9 之前则是将 returnValue 属性设置为 false。阻止事件传播可以调用 stopPropagation 方法，它可以工作在事件传播的三个阶段的任意一个阶段，如在目标元素的事件捕获阶段中调用，则目标子元素都无法触发捕获事件捕获就相当于不会触发事件本身了。IE9 之前是 cancelBunbble 属性设置为 true。 12345678910111213141516171819202122// 现代浏览器与IE9之前版本的兼容function handler(e) &#123; // addEventListener调用的事件处理函数的this是事件目标 console.log(this===e.currentTarget); // true e.preventDefault(); e.stopPropagation(); e.target.removeEventListner('click', handler, false);&#125;;function handler4IE(e) &#123; // IE9之前attachEvent的事件处理函数不会把event对象传进来，而是附加在window.event上 const event = e || window.event; // attachEvent调用的事件处理函数的this是window console.log(this===window); // true e.returnValue = false; e.cancelBunbble = true; e.target.detachEvent('click', handler4IE);&#125;;if(element.addEventListener) &#123; element.addEventListener('click', handler, false);&#125; else &#123; element.attachEvent('onclick', handler4IE);&#125; 12. Ajax 请求以及跨域 原生的 Ajax 请求代码如下: HTTP 请求的各部分有指定顺序：请求方法和 URL 首先到达，然后是请求头，最后是请求主体。XMLHTTPRequest 实现通常虽然直到调用 send()方法才开始启动网络，但是其内部 API 的设计仍要其调用顺序上按照 open、setRequestHeader、send 的顺序。 readyState 属性的 0==&gt;UNSENT(open 方法尚未调用)，1==&gt;OPENED(open 方法已调用)，2==&gt;HEADERS_RECEIVED(接收到头信息)，3==&gt;LOADING(接收到响应主体)，4==&gt;DONE(响应完成)，status 和 statusText 属性分别以数字和文本的形式返回 HTTP 状态码。 常见的状态码：200(ok，请求成功)、301(Moved Permanently，永久移动，请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替)、302(Move temporarily，临时移动，请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求)、304(Not Modified，未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源)、400(Bad Request，客户端请求的语法错误，服务器无法理解)、403(Forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求)、404(Not Found，服务器无法根据客户端的请求找到资源)、500(Internal Server Error，服务器内部错误，无法完成请求)、503(Service Unavailable，由于超载或系统维护，服务器暂时的无法处理客户端的请求)、504(Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求) 123456789const xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(JSON.parse(xhr.responseText)); &#125;&#125;;xhr.open('post', 'https://www.fs.com/FHH/EM1HER/relationPattern/listRelationPatternsByEa?traceId=E-E.2.1000-37968006&amp;_fs_token=E3WpC3GqC3WjE31YC2qqDZDXBM9YP6KjCsOtOZLbOZTZDZLY');xhr.setRequestHeader('Content-Type', 'application/json');xhr.send(JSON.stringify(&#123;describeApiName: \"PartnerObj\", is_only_active: true&#125;)); HTTP 缓存机制：https://juejin.im/post/5ab9ad5c6fb9a028c22ac671 13. 客户端存储 客户端存储技术：localStorage、sessionStorage、cookie 和 IndexedDB，它们之间的区别很大，但同时也有各自的应用范围。 localStorage：1. 存储数据格式：浏览器仅仅支持存储字符串类型数据的存储，如果存对象数据进去会将结果保存为“[object Object]”，所以存储对象数据一般讲对象 JSON.stringify()转化成字符串再存，读取时再用 JSON.parse()转回对象；2. 存储数据 API：全局对象（挂载在 window 下），可以将其当做对象一样去读取设置，如 localStorage.name=&quot;dengxy&quot;，当然这种方式无法完成删除某个属性，或者清空操作。官方提供了 getItem、setItem、removeItem、clear 方法。3. 有效期和作用域：localStorage 存储的数据是永久性的，除非 web 应用清除或者用户通过设置浏览器删除，否则它是永不过期的，而其作用域则限定在文档源（同源策略中的源）级别，同源的文档间共享同样的一份 localStorage。但是需要注意的其作用域也受浏览器类型限制，如 Chrome 和 Firefox 之间的两个同源文档肯定不共享。 1234567891011// 获取某个localStorage的属性，如果它存储的是对象JSON.stringify后的结果，请返回原对象，否则返回本身function getStorageItem(itemName) &#123; const str = localStorage.getItem(itemName); let res; try &#123; res = JSON.parse(str); &#125; catch &#123; return str; &#125; return res;&#125;; sessionStorage: 和 localStorage 一样是全局对象，存储 API，唯一区别是其作用域和有效期：同一个窗口下的同源文档之间可以共享，所以同一个浏览器下的不同的窗口之间的同源文档是能共享 localStorage 不能共享 sessionStorage 的，而同一个窗口的不同窗体(iframe)之间的同源文档可以共享 sessionStorage。而且其有效期也是该窗口的生命周期，也即关闭了该窗口 sessionStorage 也会被删除。 localStorage 和 sessionStorage 在不同作用域下的通信：storage 事件，首先这个事件只能在 localStorage 或者 sessionStorage 的内容改变时才会触发，且为其他作用域（如其他的同源窗口，同源窗体，每个域下都有自己的 window，所以每个 window 的 storage 事件也是独立的）下的 localStorage 和 sessionStorage 改变会触发本作用域的 storage 事件。 1234567891011121314window.addEventListner('storage', (&#123;type, newValue, oldValue, url&#125;) =&gt; &#123; if (type === 'localStorage') &#123; console.log(newValue, oldValue, url); &#125;&#125;);const box = document.getElementsByClassName(\"box\")[0];const ifm = document.createElement(\"iframe\");ifm.name = \"myifm\";ifm.src = \"/test.html\";box.appendChild(ifm);frames.myifm.onload = () =&gt; &#123; const oldVal = frames.localStorage.getItem('name'); frames.localStorage.setItem('name',`$&#123;oldVal || ''&#125;-changed`);&#125;; cookie: cookie 用于 web 浏览器存储少量数据，且这份数据会自动在 web 浏览器和 web 服务器之间传输。cookie 的默认有效期是 web 浏览器的会话期间，一旦用户关闭了浏览器，cookie 保存的数据就丢失了，但是也可通过设置 max-age 属性来延长其有效期。cookie 的作用域默认和创建它的 web 页面有关，对该 web 页面以及和该页面同目录或者子目录的其他 web 页面可见，比如，web 页面http://vedio.qq.com/catalog/index.html页面创建了一个cookie，那么该cookie对http://vedio.qq.com/catalog/order.html页面和http://vedio.qq.com/catalog/widgets/index.html页面都是可见的，但是它对http://vedio.qq.com/about.html页面不可见。cookie的作用域可以通过设置其domain和path属性来扩大其作用域，如把上述cookie的domain设置为’.qq.com’，path属性设置为’/’，则该cookie对http://xxx.qq.com/index.html都变成有效的。secure属性是一个布尔值，表示cookie的值是否允许以http形式通过网络传递。默认为false表示允许通过http传递的（https也可传递），但是若设置为true，则表示只允许通过https的才能传递它。对于cookie的操作，实际是操作document.cookie属性来完成，且由于cookie的名称/值中的字符串不允许包含分号、逗号和空白符，因此一般在存储和读取时用encodeURIComponent和decodeURIComponent方法，且document.cookie保存着所有的cookie，以“; ”（注意有个空格）分隔。单个 cookie 的大小不超过 4KB 大小是所有现代浏览器的限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function Cookie() &#123; const cookieObj = &#123;&#125;; const cookieStr = decodeURIComponent(document.cookie); const cookieArr = cookieStr.split('; '); cookieArr.forEach(item =&gt; &#123; const arr = item.split('='); cookieObj[arr[0]] = arr[1]; &#125;); window.cookieObj = cookieObj; return cookieObj;&#125;Cookie.prototype = &#123; constructor: Cookie, getItem(name) &#123; return cookieObj[name]; &#125;, setItem(name, value) &#123; &#125;,&#125;;function getCookie() &#123; const cookieObj = &#123;&#125;; const cookieStr = decodeURIComponent(document.cookie); const cookieArr = cookieStr.split('; '); cookieArr.forEach(item =&gt; &#123; const arr = item.split('='); cookieObj[arr[0]] = arr[1]; &#125;); return cookieObj;&#125;;getCookie() // &#123;_ga: \"GA1.2.237819427.1522062937\", _gid: \"GA1.2.440379694.1529398243\"&#125;// max-age是和当前时间的绝对值，单位是秒，表示多少秒后该cookie失效// domain和path必须和当前的url相匹配否则设置不成功// max-age设置为0，则会删除该条cookie值，但是如果该条目有非默认的'domain', 'path', 'secure'属性则必须完整的信息才会删除function setCookie(obj) &#123; const extralprops = ['max-age', 'domain', 'path', 'secure']; let str = `$&#123;encodeURIComponent(obj.name)&#125;=$&#123;encodeURIComponent(obj.value)&#125;`; extralprops.forEach(prop =&gt; &#123; prop in obj &amp;&amp; (str += `; $&#123;prop&#125;=$&#123;obj[prop]&#125;`); &#125;); console.log(str); document.cookie = str;&#125;;setCookie(&#123;name:'tester', value: 'dengxy', path: '/LChenglong/', 'max-age': 10, secure:true&#125;); // \"tester=dengxy; max-age=10; path=/LChenglong/; secure=true\"getCookie() // &#123;tester: \"dengxy\", _ga: \"GA1.2.237819427.1522062937\", _gid: \"GA1.2.440379694.1529398243\"&#125; IndexedDB：用于浏览器端存储大量数据。 14. 跨域 同源策略和跨域：同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。而源包含协议、域名和端口号三个部分，任何一个不同都是不同源。不能读取对方资源，具体体现在 1. Cookie、LocalStorage 和 SessionStorage 无法读取；2. DOM 无法获得；3. AJAX 请求不能发送。 document.domain 跨域：适应于主域名（例如 news.qq.com 和 v.qq.com）相同 同一个窗口的不同 iframe 窗体（包括_top）的 cookie 跨域：cookie 首先单条 cookie 可以设置其 domain 和 path 来扩大其作用域，可以让其和同主域名下的其他网站共享。但是如果 cookie 是服务器端传来的，其 domain 和 path 的设置已经导致 cookie 不共享，但是可以在两个窗体都设置 document.domain=&quot;qq.com&quot;，这样这两个窗体就可以互相读取对方的 document.cookie 的内容了。 iframe 窗口和 window.open 方法打开的窗口的 DOM 跨域：同上，两个窗口或窗体都设置 document.domain=&quot;qq.com&quot;后，就可以通过 document.getElementById(&quot;myIFrame&quot;).contentWindow.document 拿到子窗体的 document 对象，可以通过 window.parent.document 拿到父窗体的 document 对象。 window.name 跨域：window.name 属性的最大特点是，无论是否同源，前一个网页设置了这个属性，后一个网页可以读取它，例如前一个网页是 www.test1.com，我们在该网页 onload 后设置 window.name=dataStr（仅支持字符串），然后再跳转 www.test2.com 后，我们读取 window.name 仍然是 dataStr。所以可以利用这一点，可以先打开到一个代理界面（和当前网页同域）这样可以取到其 window 对象并且设置其 window.name，然后代理界面跳转到在目标网页（和当前网页不同域）加载完成后取到 window.name。 window.postMessage 跨域：HTML5 标准引入的专业的跨文档通信 API，MDN 的语法说明 otherWindow.postMessage(message, targetOrigin, [transfer])。再接收窗口可以注册 message 事件来接收到数据：window.addEventListener('message', foo, false); otherWindow：其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames。 message：将要发送到其他 window 的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化，即可以传对象。 targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;（表示无限制）或者一个 URI。 e.data：从其他 window 中传递过来的数据。 e.origin：事件被发起的源，返回事件发起窗口的 location.origin。 e.source：事件被发起的窗口的 window 引用。 1234567891011121314151617181920212223242526272829// 1. window.open打开的窗口之间的通信// 1.1 首先在将打开的窗口www.test.com网页必须有message事件监听window.addEventListener('message', e =&gt; &#123; if(e.origin === \"https://www.ceshi112.com\") &#123; console.log(e.data, e.source===window.opener); // &#123;tester: 'dengxy'&#125; true e.source.postMessage('done', e.origin); &#125;&#125;);// 1.2 在主页面www.ceshi112.com上打开窗口并postMessageconst testWindow = window.open('https://www.test.com');// 由于打开跨域的网址取得的window对象是无法监听onload事件的，所以无法早知道打开的网页何时渲染完成，所以做一个循环任务来监听messageEndFlagconst intervalTask = setInterval(function()&#123; // window.open打开窗口失败（网址不存在或者被浏览器拦截）时需要取消任务 if (testWindow) &#123; testWindow.postMessage( &#123; tester: 'dengxy' &#125;, 'https://www.test.com' ); &#125; else &#123; clearInterval(intervalTask); &#125;&#125;, 500);window.addEventListener('message', e =&gt; &#123; if(e.origin === \"https://www.test.com\" &amp;&amp; e.data === 'done') &#123; clearInterval(intervalTask); &#125;&#125;);// 2. iframe之间的通信与此类似 JSONP 跨域：适应于 Ajax 请求跨域，它的基本思想是，使用&lt;script&gt;元素进行 Ajax 传输不受同源策略的影响，因此可以从其他服务器请求数据，第二个原因是包含 JSON 编码数据的响应体会自动解码（执行）。所以必须是包裹后的 JSON 响应：handleResponse([1, 2, {}])，也提前定义好了全局函数 handleResponse。JSONP 只支持 GET 请求。 1234567891011// 按照指定url完成一个JSONP跨域请求并响应，假设传参(http://example.com/request, foo)，请求格式为'http://example.com/request?callback=foo'function callbackFoo (response) &#123; console.log(response);&#125;function getJSONP(url, callback) &#123; const src = `$&#123;url&#125;?callback=$&#123;callback.name&#125;`; const script = document.createElement('script'); script.src = src; document.body.appendChild(script);&#125;getJSONP('http://example.com/request', callbackFoo); CORS（Cross-Origin Resource Sharing）：跨源资源分享，需要浏览器和服务器同时支持，支持所有类型的 HTTP 请求。 15. 前端边缘知识 Date 类以及其 useful API： 创建一个 Date 类实例：new Date(), new Date(millisenconds), new Date(datestring, new Date(year, month（0-11）, day, hours, mimutes, seconds, ms) 123456const now = new Date();const old = new Date(1529571020000); // Thu Jun 21 2018 16:50:20 GMT+0800 (中国标准时间)// 默认是UTC时间0点0分0秒，所以转化成时区就变成8小时const older = new Date('2016-12-12'); // Thu Dec 12 2016 08:00:00 GMT+0800 (中国标准时间)// 前两个为必须，后面都是默认参数：日期为1，时间为0const oldest = new Date(2016, 11, 12); // Mon Dec 01 2016 00:00:00 GMT+0800 (中国标准时间) Date 函数的方法：Date.now()返回从 1970-01-01 00:00:00:000 到现在的毫秒数, Date.parse(dateString)返回+new Date(dateString)也是一个时间差的毫秒数。 Date 对象实例的方法：g[s]et[UTC]FullYear()、g[s]et[UTC]Month(0-11 表示 1-12 月)、g[s]et[UTC]Date()、g[s]et[UTC]Day(0 表示星期日)、g[s]et[UTC]Hours(0-23 表示法)、g[s]et[UTC]Minutes()、g[s]et[UTC]Seconds()、g[s]et[UTC]Milliseconds()、g[s]etTime(毫秒差值，和 valueOf()的结果一样)、getTimezoneOffset(本地时间与 UTC 时间之间相差的分钟数，如中国是-480，因为中国是+08:00，相对于 UTC 提前了 8 小时，所以 UTC-本地时间=-480) toTimeString(转化的结果前 8 为肯定为 hh:mm:ss，这对于想实现 01:00:00 秒这样的格式很有帮助) 123456789101112131415// 写一个函数实现输出当前时间如“2018年06年25日 08:00:00”格式且模拟时间每秒进行变化function showNowTime() &#123; const getNowTimeStr = function() &#123; const now = new Date(); const year = now.getFullYear(); const month = now.getMonth() + 1; const day = now.getDate(); const time = now.toTimeString().slice(0, 8); return `$&#123;year&#125;年$&#123;month &lt; 10 ? '0' + month: month&#125;月$&#123;day &lt; 10 ? '0' + day: day&#125;日 $&#123;time&#125;` &#125;; const timeBox = document.getElementsByClassName('j-time-box')[0]; return setInterval(() =&gt; &#123; timeBox.textContent = getNowTimeStr(); &#125;, 1000);&#125; throw、try、catch、finally 语句：js 运行过程中，可能出现一些错误，而且任何一个 js 的报错都会阻塞其运行然后不会往下执行。这个时候把可能出错的代码放 try{}代码块中，catch{}代码块来捕获错误做出对应的举措，如某些错误就 throw 抛出，某些错误就可以接受。finally{}代码块是代码最终一定会执行的部分，相对来说 catch{}就是只有出错才会执行的部分。 throw 语句模拟的就是真正的 js 报错，所以其只会往上抛出错误（本层代码也会终止继续运行），如果外层里有 catch 语句则进入 catch 语句内运行，否则直接抛出到工作台且中断 JS 的运行（JS 是单线程所以一旦抛出一个没有 catch 的错误之后的语句都不会运行）。如果只是想工作台报错提醒，可以试试 console.err(errorInfo)，这个不会中断 JS 运行。 1234567891011121314function testThrow() &#123; (function () &#123; throw \"报错！\"; console.log('内部'); &#125;)(); console.log('外部');&#125;;testThrow(); // 工作台抛出报错，无论“内部”或者“外部”都不会打印/* --------------------------- */try &#123; testThrow();&#125; catch(err) &#123; console.log(err); // 打印出“报错！”&#125; finally 语句就是在 try、catch 语句之后的一定会执行的部分，无论是否是否报错。 1234567891011121314151617181920function testFinally(jsonStr) &#123; try &#123; JSON.parse(jsonStr); &#125; catch(err) &#123; console.error('出错啦'); throw err; &#125; finally &#123; console.log('1:finally里的无论如何都会执行'); &#125; console.log('2:try语句所在代码块同级别的出错时不会继续运行，但是没有出错时会运行');&#125;testFinally(\"[&#123;a:1&#125;]\");console.log('3:如果没有throw error到外层或工作台时外层仍运行，否则不执行'); // 仅log 1/* --------------------------- */testFinally(\"[&#123;'a':1&#125;]\");console.log('3:如果没有throw error到外层或工作台时外层仍运行，否则不执行'); // 仅log 1/* --------------------------- */testFinally('[&#123;\"a\":1&#125;]');console.log('3:如果没有throw error到外层或工作台时外层仍运行，否则不执行'); // log 1 2 3 try、catch、finally 在函数中，遇到 return 语句产生的化学反应。 123456789101112// 即使try或者catch中有返回值了，但是仍然会执行finally代码块的代码，且若里面有return语句会覆盖之前的returnfunction parseJSON(str) &#123; try &#123; return JSON.parse(str); &#125; catch(err) &#123; return &#123;&#125;; &#125; finally &#123; return &#123; finally: 123 &#125;; &#125;&#125;parseJSON('[&#123;\"a\":1&#125;]'); // &#123;finally: 123&#125;parseJSON(\"[&#123;a:1&#125;]\"); // &#123;finally: 123&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://dengxianyu.gitee.io/categories/JavaScript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://dengxianyu.gitee.io/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://dengxianyu.gitee.io/tags/JavaScript/"}]}]